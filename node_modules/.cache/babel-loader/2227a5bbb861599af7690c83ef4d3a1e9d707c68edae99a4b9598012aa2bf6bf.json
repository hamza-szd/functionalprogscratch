{"ast":null,"code":"import{difference}from\"lodash\";import{isConcreteType,isForallType,isTypeNameHole,isTypeVar,isTypeVarBoundBy,isTypeVarSlot,typeParams,typeVarsBoundBy}from\"./type\";export function typeSubstitute(type,sub){if(isTypeVarSlot(type)){return type;}else if(isTypeVar(type)){var _sub$type$var;return(_sub$type$var=sub[type.var])!==null&&_sub$type$var!==void 0?_sub$type$var:type;}else if(isForallType(type)){return{forall:type.forall,body:typeSubstitute(type.body,sub)};}else{const tag=type.tag;const params=typeParams(type).map(typeParam=>typeSubstitute(typeParam,sub));return params.length?{tag,of:params}:{tag};}}export function typeVarsFreeIn(type){if(isTypeVar(type)){return[type.var];}else if(isForallType(type)){const freeInBody=typeVarsFreeIn(type.body);const shadowed=typeVarsBoundBy(type);return difference(freeInBody,shadowed);}else if(isConcreteType(type)){var _type$of;return((_type$of=type.of)!==null&&_type$of!==void 0?_type$of:[]).flatMap(typeVarsFreeIn);}else if(isTypeNameHole(type)){return[];}throw\"invalid type passed to typeVarsFreeIn\";}export function typeVarOccurs(typeVarName,type){if(isTypeVar(type)){return type.var===typeVarName;}else if(isForallType(type)){if(isTypeVarBoundBy(typeVarName,type)){// Shadowed\nreturn false;}return typeVarOccurs(typeVarName,type.body);}else if(isConcreteType(type)){var _type$of2;return((_type$of2=type.of)!==null&&_type$of2!==void 0?_type$of2:[]).some(child=>typeVarOccurs(typeVarName,child));}else if(isTypeNameHole(type)){return false;}throw\"invalid type passed to typeVarOccurs\";}","map":{"version":3,"names":["difference","isConcreteType","isForallType","isTypeNameHole","isTypeVar","isTypeVarBoundBy","isTypeVarSlot","typeParams","typeVarsBoundBy","typeSubstitute","type","sub","_sub$type$var","var","forall","body","tag","params","map","typeParam","length","of","typeVarsFreeIn","freeInBody","shadowed","_type$of","flatMap","typeVarOccurs","typeVarName","_type$of2","some","child"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/typechecker/type-substitution.ts"],"sourcesContent":["import { difference } from \"lodash\";\nimport {\n  Type,\n  isConcreteType,\n  isForallType,\n  isTypeNameHole,\n  isTypeVar,\n  isTypeVarBoundBy,\n  isTypeVarSlot,\n  typeParams,\n  typeVarsBoundBy,\n} from \"./type\";\n\nexport type TypeSubstitution = Record<string, Type>;\n\nexport function typeSubstitute(type: Type, sub: TypeSubstitution): Type {\n  if (isTypeVarSlot(type)) {\n    return type;\n  } else if (isTypeVar(type)) {\n    return sub[type.var] ?? type;\n  } else if (isForallType(type)) {\n    return {\n      forall: type.forall,\n      body: typeSubstitute(type.body, sub),\n    };\n  } else {\n    const tag = type.tag;\n    const params = typeParams(type).map((typeParam) => typeSubstitute(typeParam, sub));\n    return params.length ? { tag, of: params } : { tag };\n  }\n}\n\nexport function typeVarsFreeIn(type: Type): string[] {\n  if (isTypeVar(type)) {\n    return [type.var];\n  } else if (isForallType(type)) {\n    const freeInBody = typeVarsFreeIn(type.body);\n    const shadowed = typeVarsBoundBy(type);\n    return difference(freeInBody, shadowed);\n  } else if (isConcreteType(type)) {\n    return (type.of ?? []).flatMap(typeVarsFreeIn);\n  } else if (isTypeNameHole(type)) {\n    return [];\n  }\n  throw \"invalid type passed to typeVarsFreeIn\";\n}\n\nexport function typeVarOccurs(typeVarName: string, type: Type): boolean {\n  if (isTypeVar(type)) {\n    return type.var === typeVarName;\n  } else if (isForallType(type)) {\n    if (isTypeVarBoundBy(typeVarName, type)) {\n      // Shadowed\n      return false;\n    }\n    return typeVarOccurs(typeVarName, type.body);\n  } else if (isConcreteType(type)) {\n    return (type.of ?? []).some((child) => typeVarOccurs(typeVarName, child));\n  } else if (isTypeNameHole(type)) {\n    return false;\n  }\n  throw \"invalid type passed to typeVarOccurs\";\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}