{"ast":null,"code":"/**\n * Static type (of an expression).\n *\n * To find the best available static type for an expression, use `Typechecker`.\n */ /**\n * Static type (of an expression).\n *\n * e.g.,\n *  - `Int`\n *  - `List[Any]`\n *  - `Function[Int, String]`\n */export function isConcreteType(type){return\"tag\"in type;}export function typeParams(type){var _type$of;if(isTypeVar(type)||isTypeVarSlot(type))return[];if(isForallType(type))return typeParams(type.body);return(_type$of=type.of)!==null&&_type$of!==void 0?_type$of:[];}export function functionParamTypes(fnType){return typeParams(fnType).slice(0,-1);}export function functionResultType(fnType){var _typeParams$at;return(_typeParams$at=typeParams(fnType).at(-1))!==null&&_typeParams$at!==void 0?_typeParams$at:Any;}export function functionMinArgCount(type){if(isForallType(type)){return functionMinArgCount(type.body);}else if(hasTag(type,\"Function\")){var _type$of$length,_type$of2;return((_type$of$length=(_type$of2=type.of)===null||_type$of2===void 0?void 0:_type$of2.length)!==null&&_type$of$length!==void 0?_type$of$length:1)-/* return type */1;}else if(hasTag(type,\"Function*\")){var _type$minArgCount;return(_type$minArgCount=type.minArgCount)!==null&&_type$minArgCount!==void 0?_type$minArgCount:type.of.length-/* one for vararg (zero or more), one for return type */2;}else{return 0;}}export function functionMaxArgCount(type){if(isForallType(type)){return functionMaxArgCount(type.body);}else if(hasTag(type,\"Function\")){var _type$of$length2,_type$of3;return((_type$of$length2=(_type$of3=type.of)===null||_type$of3===void 0?void 0:_type$of3.length)!==null&&_type$of$length2!==void 0?_type$of$length2:1)-1;}else if(hasTag(type,\"Function*\")){var _type$maxArgCount;return(_type$maxArgCount=type.maxArgCount)!==null&&_type$maxArgCount!==void 0?_type$maxArgCount:Infinity;}else{return Infinity;}}export function hasTag(type,tag){return isConcreteType(type)&&type.tag===tag;}export function isTypeVarSlot(type){return isTypeNameHole(type)||isTypeNameBinding(type);}export function isForallType(type){return\"forall\"in type;}export function typeVarsBoundBy(forallType){return forallType.forall.map(slot=>isTypeVar(slot)&&slot.var).filter(x=>x);}export function isTypeVarBoundBy(typeVarName,forallType){return forallType.forall.some(slot=>isTypeVar(slot)&&slot.var===typeVarName);}export function isTypeNameHole(type){return\"kind\"in type&&type.kind===\"type-name-hole\";}export function isTypeNameBinding(type){return\"kind\"in type&&type.kind===\"type-name-binding\";}/**\n * Placeholder for a type in a polymorphic type expression.\n *\n * e.g.,\n *  - the identity function has type `Function[a, a]`, where `a` is an unconstrained `TypeVar`\n *  - `cons` has type `Function[a, Function[List[a], List[a | b]]]`\n *    (among others), where `a` and `b` are unconstrained `TypeVar`s\n */export function isTypeVar(type){return\"var\"in type;}export const Untyped={tag:\"?\"};export const Any={tag:\"Any\"};export const Never={tag:\"Never\"};export function typeParamMap(t,fn){if(isTypeVar(t)||isTypeVarSlot(t)){return t;}else if(isForallType(t)){return{forall:t.forall,body:typeParamMap(t.body,fn)};}else{const tag=t.tag;const params=typeParams(t).map(fn);return params.length?{tag,of:params}:{tag};}}","map":{"version":3,"names":["isConcreteType","type","typeParams","_type$of","isTypeVar","isTypeVarSlot","isForallType","body","of","functionParamTypes","fnType","slice","functionResultType","_typeParams$at","at","Any","functionMinArgCount","hasTag","_type$of$length","_type$of2","length","_type$minArgCount","minArgCount","functionMaxArgCount","_type$of$length2","_type$of3","_type$maxArgCount","maxArgCount","Infinity","tag","isTypeNameHole","isTypeNameBinding","typeVarsBoundBy","forallType","forall","map","slot","var","filter","x","isTypeVarBoundBy","typeVarName","some","kind","Untyped","Never","typeParamMap","t","fn","params"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/typechecker/type.ts"],"sourcesContent":["/**\n * Static type (of an expression).\n *\n * To find the best available static type for an expression, use `Typechecker`.\n */\nexport type Type = ConcreteType | ForallType | TypeVar | TypeVarSlot;\n\n/**\n * Static type (of an expression).\n *\n * e.g.,\n *  - `Int`\n *  - `List[Any]`\n *  - `Function[Int, String]`\n */\nexport type ConcreteType = SimpleConcreteType | VariadicFunctionType;\n\nexport type SimpleConcreteType<Tag extends string = string> = {\n  tag: Tag;\n  of?: Type[];\n};\n\nexport type VariadicFunctionType = {\n  tag: \"Function*\";\n  of: Type[];\n\n  minArgCount?: number;\n  maxArgCount?: number;\n};\n\nexport function isConcreteType(type: Type): type is ConcreteType {\n  return \"tag\" in type;\n}\n\nexport function typeParams(type: Type): Type[] {\n  if (isTypeVar(type) || isTypeVarSlot(type)) return [];\n  if (isForallType(type)) return typeParams(type.body);\n  return type.of ?? [];\n}\n\nexport function functionParamTypes(\n  fnType: SimpleConcreteType<\"Function\"> | VariadicFunctionType,\n): Type[] {\n  return typeParams(fnType).slice(0, -1);\n}\nexport function functionResultType(\n  fnType: SimpleConcreteType<\"Function\"> | VariadicFunctionType,\n): Type {\n  return typeParams(fnType).at(-1) ?? Any;\n}\n\nexport function functionMinArgCount(type: Type): number {\n  if (isForallType(type)) {\n    return functionMinArgCount(type.body);\n  } else if (hasTag(type, \"Function\")) {\n    return (type.of?.length ?? 1) - /* return type */ 1;\n  } else if (hasTag(type, \"Function*\")) {\n    return (\n      type.minArgCount ??\n      type.of.length - /* one for vararg (zero or more), one for return type */ 2\n    );\n  } else {\n    return 0;\n  }\n}\n\nexport function functionMaxArgCount(type: Type): number {\n  if (isForallType(type)) {\n    return functionMaxArgCount(type.body);\n  } else if (hasTag(type, \"Function\")) {\n    return (type.of?.length ?? 1) - 1;\n  } else if (hasTag(type, \"Function*\")) {\n    return type.maxArgCount ?? Infinity;\n  } else {\n    return Infinity;\n  }\n}\n\nexport function hasTag<Tag extends string>(type: Type, tag: Tag): type is SimpleConcreteType<Tag>;\nexport function hasTag(type: Type, tag: \"Function*\"): type is VariadicFunctionType;\n\nexport function hasTag<Tag extends string>(type: Type, tag: Tag): boolean {\n  return isConcreteType(type) && type.tag === tag;\n}\n\nexport type TypeVarSlot = TypeNameHole | TypeNameBinding;\nexport function isTypeVarSlot(type: Type): type is TypeVarSlot {\n  return isTypeNameHole(type) || isTypeNameBinding(type);\n}\n\nexport type ForallType = {\n  /** Type variable names. */\n  forall: TypeVarSlot[];\n  body: Type;\n};\nexport function isForallType(type: Type): type is ForallType {\n  return \"forall\" in type;\n}\nexport function typeVarsBoundBy(forallType: ForallType): string[] {\n  return forallType.forall.map((slot) => isTypeVar(slot) && slot.var).filter((x) => x) as string[];\n}\nexport function isTypeVarBoundBy(typeVarName: string, forallType: ForallType) {\n  return forallType.forall.some((slot) => isTypeVar(slot) && slot.var === typeVarName);\n}\n\nexport type TypeNameHole = {\n  kind: \"type-name-hole\";\n};\nexport function isTypeNameHole(type: Type): type is TypeNameHole {\n  return \"kind\" in type && type.kind === \"type-name-hole\";\n}\n\nexport type TypeNameBinding = {\n  kind: \"type-name-binding\";\n  id: string;\n};\nexport function isTypeNameBinding(type: Type): type is TypeNameBinding {\n  return \"kind\" in type && type.kind === \"type-name-binding\";\n}\n\n/**\n * Placeholder for a type in a polymorphic type expression.\n *\n * e.g.,\n *  - the identity function has type `Function[a, a]`, where `a` is an unconstrained `TypeVar`\n *  - `cons` has type `Function[a, Function[List[a], List[a | b]]]`\n *    (among others), where `a` and `b` are unconstrained `TypeVar`s\n */\nexport type TypeVar = {\n  /** Type variable name. */\n  var: string;\n};\nexport function isTypeVar(type: Type): type is TypeVar {\n  return \"var\" in type;\n}\n\nexport type BuiltinType =\n  | { tag: \"Any\" }\n  | { tag: \"Never\" }\n  | { tag: \"Empty\" }\n  | { tag: \"Number\" }\n  | { tag: \"Integer\" }\n  | { tag: \"Boolean\" }\n  | { tag: \"String\" }\n  | { tag: \"Symbol\" }\n  | { tag: \"List\"; of: [element: Type] }\n  | { tag: \"Function\"; of: Type[] }\n  | { tag: \"Component\"; of: [state: Type] };\n\nexport const Untyped: SimpleConcreteType<\"?\"> = { tag: \"?\" };\nexport const Any: SimpleConcreteType<\"Any\"> = { tag: \"Any\" };\nexport const Never: SimpleConcreteType<\"Never\"> = { tag: \"Never\" };\n\nexport function typeParamMap(t: Type, fn: (t_: Type, index: number) => Type): Type {\n  if (isTypeVar(t) || isTypeVarSlot(t)) {\n    return t;\n  } else if (isForallType(t)) {\n    return {\n      forall: t.forall,\n      body: typeParamMap(t.body, fn),\n    };\n  } else {\n    const tag = t.tag;\n    const params = typeParams(t).map(fn);\n    return params.length ? { tag, of: params } : { tag };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}