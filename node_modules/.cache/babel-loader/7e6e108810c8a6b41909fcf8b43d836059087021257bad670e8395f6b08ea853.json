{"ast":null,"code":"import{isEqual}from\"lodash\";import{isTypeVar,hasTag,typeParams,functionParamTypes,functionResultType,Any,Never,isForallType,isConcreteType,isTypeVarSlot,Untyped}from\"./type\";function typeCombine(t1,t2,takeMin,giveUpType,typeCombineSame,typeCombineOpposite){var _t1$of,_t2$of;if(hasTag(t1,Untyped.tag))return t1;if(hasTag(t2,Untyped.tag))return t2;if(isSubtype(t1,t2,true))return takeMin?t1:t2;if(isSubtype(t2,t1,true))return takeMin?t2:t1;if(isTypeVar(t1)||isTypeVar(t2)||isTypeVarSlot(t1)||isTypeVarSlot(t2))return giveUpType;if(isForallType(t1)||isForallType(t2)){return isForallType(t1)&&isForallType(t2)&&isEqual(t1.forall,t2.forall)?{forall:t1.forall,body:typeCombineSame(t1.body,t2.body)}:giveUpType;}// Concrete type\nif(t1.tag!==t2.tag)return giveUpType;const t1Params=(_t1$of=t1.of)!==null&&_t1$of!==void 0?_t1$of:[];const t2Params=(_t2$of=t2.of)!==null&&_t2$of!==void 0?_t2$of:[];const signs=typeParamVariance(t1);if(signs.some(sign=>sign===\"invariant\")){return giveUpType;}const newTypeParams=signs.map((sign,index)=>{switch(sign){case\"covariant\":return typeCombineSame(t1Params[index],t2Params[index]);case\"contravariant\":return typeCombineOpposite(t1Params[index],t2Params[index]);case\"invariant\":throw\"unreachable\";}});return newTypeParams.length?{tag:t1.tag,of:newTypeParams}:{tag:t1.tag};}export function typeMeet(t1,t2){return typeCombine(t1,t2,true,Never,typeMeet,typeJoin);}export function typeJoin(t1,t2){return typeCombine(t1,t2,false,Any,typeJoin,typeMeet);}export function isSubtype(t1,t2){let knownOnly=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(hasTag(t1,Untyped.tag)||hasTag(t2,Untyped.tag))return!knownOnly;return hasTag(t1,Never.tag)||hasTag(t2,Any.tag)||isTypeVar(t1)&&isTypeVar(t2)&&t1.var===t2.var||isForallType(t1)&&isForallType(t2)&&isForallSubtype(t1,t2,knownOnly)||isConcreteType(t1)&&isConcreteType(t2)&&isConcreteSubtype(t1,t2,knownOnly);}function isForallSubtype(t1,t2,knownOnly){return isEqual(t1.forall,t2.forall)&&isSubtype(t1.body,t2.body,knownOnly);}function isConcreteSubtype(t1,t2,knownOnly){if(isNominalSubtype(t1,t2))return true;if(hasTag(t1,\"Function*\")){// Variadic functions are a limited form of (possibly infinite) intersection types;\n// as such, they have special subtyping rules.\nreturn isVariadicSubtype(t1,t2,knownOnly);}if(t1.tag!==t2.tag)return false;const t1Params=typeParams(t1);const t2Params=typeParams(t2);if(t1Params.length!==t2Params.length)return false;return typeParamVariance(t1).every((variance,index)=>{switch(variance){case\"covariant\":return isSubtype(t1Params[index],t2Params[index],knownOnly);case\"contravariant\":return isSubtype(t2Params[index],t1Params[index],knownOnly);case\"invariant\":return isEqual(t1Params[index],t2Params[index]);}});}function isNominalSubtype(t1,t2){function matches(type,tag,argCount){var _type$of$length,_type$of;return type.tag===tag&&((_type$of$length=(_type$of=type.of)===null||_type$of===void 0?void 0:_type$of.length)!==null&&_type$of$length!==void 0?_type$of$length:0)===argCount;}return matches(t1,\"Integer\",0)&&matches(t2,\"Number\",0)||matches(t1,\"Empty\",0)&&matches(t2,\"List\",1);}function isVariadicSubtype(variadic,t2,knownOnly){if(hasTag(t2,\"Function*\")){return isEqual(variadic,t2);}if(hasTag(t2,\"Function\")){var _variadic$minArgCount,_variadic$maxArgCount;const variadicParams=functionParamTypes(variadic);const variadicResult=functionResultType(variadic);const fnParams=functionParamTypes(t2);const fnResult=functionResultType(t2);if(!variadicResult||!fnResult||!variadicParams.length)return false;return(// Number of function arguments is within variadic bounds?\n((_variadic$minArgCount=variadic.minArgCount)!==null&&_variadic$minArgCount!==void 0?_variadic$minArgCount:0)<=fnParams.length&&fnParams.length<=((_variadic$maxArgCount=variadic.maxArgCount)!==null&&_variadic$maxArgCount!==void 0?_variadic$maxArgCount:Infinity)&&// Variadic result type can be assigned to function result type?\nisSubtype(variadicResult,fnResult,knownOnly)&&// Function parameter types can be assigned to variadic parameter types?\n// If there are more function parameter types than variadic parameter types,\n// the last variadic parameter type T is treated as T* (Kleene star, repeating 0+ times).\nfnParams.every((fnParam,index)=>{var _variadicParams$index;return isSubtype(fnParam,(_variadicParams$index=variadicParams[index])!==null&&_variadicParams$index!==void 0?_variadicParams$index:variadicParams.at(-1),knownOnly);}));}return false;}export function typeParamVariance(t){var _t$of;const typeParams=(_t$of=t.of)!==null&&_t$of!==void 0?_t$of:[];switch(t.tag){case\"List\":return typeParams.map(()=>\"covariant\");case\"Function\":return typeParams.map((param,index)=>index===typeParams.length-1?\"covariant\":\"contravariant\");default:return typeParams.map(()=>\"invariant\");}}","map":{"version":3,"names":["isEqual","isTypeVar","hasTag","typeParams","functionParamTypes","functionResultType","Any","Never","isForallType","isConcreteType","isTypeVarSlot","Untyped","typeCombine","t1","t2","takeMin","giveUpType","typeCombineSame","typeCombineOpposite","_t1$of","_t2$of","tag","isSubtype","forall","body","t1Params","of","t2Params","signs","typeParamVariance","some","sign","newTypeParams","map","index","length","typeMeet","typeJoin","knownOnly","arguments","undefined","var","isForallSubtype","isConcreteSubtype","isNominalSubtype","isVariadicSubtype","every","variance","matches","type","argCount","_type$of$length","_type$of","variadic","_variadic$minArgCount","_variadic$maxArgCount","variadicParams","variadicResult","fnParams","fnResult","minArgCount","maxArgCount","Infinity","fnParam","_variadicParams$index","at","t","_t$of","param"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/typechecker/subtyping.ts"],"sourcesContent":["import { isEqual } from \"lodash\";\nimport {\n  Type,\n  isTypeVar,\n  ConcreteType,\n  hasTag,\n  typeParams,\n  VariadicFunctionType,\n  functionParamTypes,\n  functionResultType,\n  Any,\n  Never,\n  isForallType,\n  isConcreteType,\n  ForallType,\n  isTypeVarSlot,\n  Untyped,\n} from \"./type\";\n\nfunction typeCombine(\n  t1: Type,\n  t2: Type,\n  takeMin: boolean,\n  giveUpType: Type,\n  typeCombineSame: (t1: Type, t2: Type) => Type,\n  typeCombineOpposite: (t1: Type, t2: Type) => Type,\n): Type {\n  if (hasTag(t1, Untyped.tag)) return t1;\n  if (hasTag(t2, Untyped.tag)) return t2;\n  if (isSubtype(t1, t2, true)) return takeMin ? t1 : t2;\n  if (isSubtype(t2, t1, true)) return takeMin ? t2 : t1;\n\n  if (isTypeVar(t1) || isTypeVar(t2) || isTypeVarSlot(t1) || isTypeVarSlot(t2)) return giveUpType;\n\n  if (isForallType(t1) || isForallType(t2)) {\n    return isForallType(t1) && isForallType(t2) && isEqual(t1.forall, t2.forall)\n      ? { forall: t1.forall, body: typeCombineSame(t1.body, t2.body) }\n      : giveUpType;\n  }\n\n  // Concrete type\n  if (t1.tag !== t2.tag) return giveUpType;\n\n  const t1Params = t1.of ?? [];\n  const t2Params = t2.of ?? [];\n  const signs = typeParamVariance(t1);\n\n  if (signs.some((sign) => sign === \"invariant\")) {\n    return giveUpType;\n  }\n\n  const newTypeParams = signs.map((sign, index) => {\n    switch (sign) {\n      case \"covariant\":\n        return typeCombineSame(t1Params[index]!, t2Params[index]!);\n      case \"contravariant\":\n        return typeCombineOpposite(t1Params[index]!, t2Params[index]!);\n      case \"invariant\":\n        throw \"unreachable\";\n    }\n  });\n\n  return newTypeParams.length\n    ? {\n        tag: t1.tag,\n        of: newTypeParams,\n      }\n    : { tag: t1.tag };\n}\n\nexport function typeMeet(t1: Type, t2: Type): Type {\n  return typeCombine(t1, t2, true, Never, typeMeet, typeJoin);\n}\n\nexport function typeJoin(t1: Type, t2: Type): Type {\n  return typeCombine(t1, t2, false, Any, typeJoin, typeMeet);\n}\n\nexport function isSubtype(t1: Type, t2: Type, knownOnly = false) {\n  if (hasTag(t1, Untyped.tag) || hasTag(t2, Untyped.tag)) return !knownOnly;\n  return (\n    hasTag(t1, Never.tag) ||\n    hasTag(t2, Any.tag) ||\n    (isTypeVar(t1) && isTypeVar(t2) && t1.var === t2.var) ||\n    (isForallType(t1) && isForallType(t2) && isForallSubtype(t1, t2, knownOnly)) ||\n    (isConcreteType(t1) && isConcreteType(t2) && isConcreteSubtype(t1, t2, knownOnly))\n  );\n}\n\nfunction isForallSubtype(t1: ForallType, t2: ForallType, knownOnly: boolean): boolean {\n  return isEqual(t1.forall, t2.forall) && isSubtype(t1.body, t2.body, knownOnly);\n}\n\nfunction isConcreteSubtype(t1: ConcreteType, t2: ConcreteType, knownOnly: boolean): boolean {\n  if (isNominalSubtype(t1, t2)) return true;\n\n  if (hasTag(t1, \"Function*\")) {\n    // Variadic functions are a limited form of (possibly infinite) intersection types;\n    // as such, they have special subtyping rules.\n    return isVariadicSubtype(t1, t2, knownOnly);\n  }\n\n  if (t1.tag !== t2.tag) return false;\n\n  const t1Params = typeParams(t1);\n  const t2Params = typeParams(t2);\n  if (t1Params.length !== t2Params.length) return false;\n\n  return typeParamVariance(t1).every((variance, index) => {\n    switch (variance) {\n      case \"covariant\":\n        return isSubtype(t1Params[index]!, t2Params[index]!, knownOnly);\n      case \"contravariant\":\n        return isSubtype(t2Params[index]!, t1Params[index]!, knownOnly);\n      case \"invariant\":\n        return isEqual(t1Params[index], t2Params[index]);\n    }\n  });\n}\n\nfunction isNominalSubtype(t1: ConcreteType, t2: ConcreteType): boolean {\n  function matches(type: ConcreteType, tag: string, argCount: number) {\n    return type.tag === tag && (type.of?.length ?? 0) === argCount;\n  }\n\n  return (\n    (matches(t1, \"Integer\", 0) && matches(t2, \"Number\", 0)) ||\n    (matches(t1, \"Empty\", 0) && matches(t2, \"List\", 1))\n  );\n}\n\nfunction isVariadicSubtype(variadic: VariadicFunctionType, t2: ConcreteType, knownOnly: boolean) {\n  if (hasTag(t2, \"Function*\")) {\n    return isEqual(variadic, t2);\n  }\n\n  if (hasTag(t2, \"Function\")) {\n    const variadicParams = functionParamTypes(variadic);\n    const variadicResult = functionResultType(variadic);\n\n    const fnParams = functionParamTypes(t2);\n    const fnResult = functionResultType(t2);\n\n    if (!variadicResult || !fnResult || !variadicParams.length) return false;\n\n    return (\n      // Number of function arguments is within variadic bounds?\n      (variadic.minArgCount ?? 0) <= fnParams.length &&\n      fnParams.length <= (variadic.maxArgCount ?? Infinity) &&\n      // Variadic result type can be assigned to function result type?\n      isSubtype(variadicResult, fnResult, knownOnly) &&\n      // Function parameter types can be assigned to variadic parameter types?\n      // If there are more function parameter types than variadic parameter types,\n      // the last variadic parameter type T is treated as T* (Kleene star, repeating 0+ times).\n      fnParams.every((fnParam, index) =>\n        isSubtype(fnParam, variadicParams[index] ?? variadicParams.at(-1)!, knownOnly),\n      )\n    );\n  }\n\n  return false;\n}\n\nexport type TypeParamVariance = \"covariant\" | \"contravariant\" | \"invariant\";\n\nexport function typeParamVariance(t: ConcreteType): TypeParamVariance[] {\n  const typeParams = t.of ?? [];\n\n  switch (t.tag) {\n    case \"List\":\n      return typeParams.map(() => \"covariant\");\n    case \"Function\":\n      return typeParams.map((param, index) =>\n        index === typeParams.length - 1 ? \"covariant\" : \"contravariant\",\n      );\n    default:\n      return typeParams.map(() => \"invariant\");\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}