{"ast":null,"code":"import{mapValues}from\"lodash\";import{Any,Never,Untyped,isForallType,isTypeVar,isTypeVarBoundBy,isTypeVarSlot}from\"../type\";import{typeVarsFreeIn}from\"../type-substitution\";import{TopConstraint,constraintMeet,isConstraintSatisfiable}from\"./constraint\";import{typeParamVariance}from\"../subtyping\";export function constraintSetMeet(first,second){const names=[...new Set([...Object.keys(first),...Object.keys(second)]).values()];const constraintSet=Object.fromEntries(names.map(name=>{var _first$name,_second$name;return[name,constraintMeet((_first$name=first[name])!==null&&_first$name!==void 0?_first$name:TopConstraint,(_second$name=second[name])!==null&&_second$name!==void 0?_second$name:TopConstraint)];}));if(Object.values(constraintSet).some(constraint=>constraint===undefined)){return undefined;}return constraintSet;}export function constraintSetsMeet(constraintSets){return constraintSets.reduce(constraintSetMeet,{});}export function areConstraintsSatisfiable(constraints){return Object.values(constraints).every(isConstraintSatisfiable);}const NoMinimalSubstitution={};/**\n * Computes a minimal (most informative) solution for `constraints` on `type`.\n */export function computeMinimalSubstitution(constraints,type){if(!areConstraintsSatisfiable(constraints))return undefined;for(const typeVar of typeVarsFreeIn(type)){constraints[typeVar]??={constraint:\"subtype\",lowerBound:Never,upperBound:Any};}try{return mapValues(constraints,(constraint,name)=>{if(constraint.constraint===\"untyped\")return Untyped;// TODO: Handle equality constraints for bounded quantification\nif(constraint.constraint===\"equal\")throw\"TODO\";const variance=varianceForTypeVar(type,name);switch(variance){case\"constant\":case\"covariant\":return constraint.lowerBound;case\"contravariant\":return constraint.upperBound;case\"invariant\":// Design choice: Return a non-best type that is reasonable in most cases.\n// This may mean that inference produces a less specific type than may be obtained\n// by manual annotations.\n// However, in practice, this does not seem to be much of an issue.\n//\n// Typed Racket appears to make a similar design tradeoff.\n// e.g.,\n//\n//   (: mklst (All (X) (X -> (MListof X))))\n//   (define (mklst x) (mcons x null))\n//\n//   (: mkempty (All (X) (-> (MListof X))))\n//   (define (mkempty) null)\n//\n//   (define l1 (mklst 1)) ; (:print-type l1) gives (MListof Integer)\n//   (define l2 (mkempty)) ; (:print-type l2) gives (MListof Any)\n//\n// where local type inference succeeds, even though the `MListof` type constructor\n// is invariant in its parameter.\n//\n// For a deeper exploration of the issue at hand, see the technical report\n// \"How good is local type inference?\" by Hosoya and Pierce [https://repository.upenn.edu/handle/20.500.14332/7082],\n// especially sections 3.2 and 4.1.\nreturn constraint.lowerBound;}});}catch(error){if(error===NoMinimalSubstitution)return undefined;throw error;}}function negateVariance(variance){switch(variance){case\"constant\":case\"invariant\":return variance;case\"covariant\":return\"contravariant\";case\"contravariant\":return\"covariant\";}}function zeroVariance(variance){switch(variance){case\"constant\":return variance;case\"invariant\":case\"covariant\":case\"contravariant\":return\"invariant\";}}function signAdjustVariance(variance,sign){switch(sign){case\"covariant\":return variance;case\"contravariant\":return negateVariance(variance);case\"invariant\":return zeroVariance(variance);}}function varianceForTypeVar(type,typeVarName){if(isTypeVarSlot(type)){return\"constant\";}else if(isTypeVar(type)){return type.var===typeVarName?\"covariant\":\"constant\";}else if(isForallType(type)){if(isTypeVarBoundBy(typeVarName,type)){// Shadowed\nreturn\"constant\";}return varianceForTypeVar(type.body,typeVarName);}else{var _type$of;const signs=typeParamVariance(type);const typeArgVariances=((_type$of=type.of)!==null&&_type$of!==void 0?_type$of:[]).map(typeArg=>varianceForTypeVar(typeArg,typeVarName)).map((variance,index)=>signAdjustVariance(variance,signs[index]));const hasCovariantArg=typeArgVariances.includes(\"covariant\");const hasContravariantArg=typeArgVariances.includes(\"contravariant\");const hasInvariantArg=typeArgVariances.includes(\"invariant\");if(hasInvariantArg||hasCovariantArg&&hasContravariantArg){return\"invariant\";}else if(hasCovariantArg){return\"covariant\";}else if(hasContravariantArg){return\"contravariant\";}else{return\"constant\";}}}","map":{"version":3,"names":["mapValues","Any","Never","Untyped","isForallType","isTypeVar","isTypeVarBoundBy","isTypeVarSlot","typeVarsFreeIn","TopConstraint","constraintMeet","isConstraintSatisfiable","typeParamVariance","constraintSetMeet","first","second","names","Set","Object","keys","values","constraintSet","fromEntries","map","name","_first$name","_second$name","some","constraint","undefined","constraintSetsMeet","constraintSets","reduce","areConstraintsSatisfiable","constraints","every","NoMinimalSubstitution","computeMinimalSubstitution","type","typeVar","lowerBound","upperBound","variance","varianceForTypeVar","error","negateVariance","zeroVariance","signAdjustVariance","sign","typeVarName","var","body","_type$of","signs","typeArgVariances","of","typeArg","index","hasCovariantArg","includes","hasContravariantArg","hasInvariantArg"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/typechecker/constraints/constraint-set.ts"],"sourcesContent":["import { mapValues } from \"lodash\";\nimport {\n  Any,\n  Never,\n  Type,\n  Untyped,\n  isForallType,\n  isTypeVar,\n  isTypeVarBoundBy,\n  isTypeVarSlot,\n} from \"../type\";\nimport { TypeSubstitution, typeVarsFreeIn } from \"../type-substitution\";\nimport { Constraint, TopConstraint, constraintMeet, isConstraintSatisfiable } from \"./constraint\";\nimport { TypeParamVariance, typeParamVariance } from \"../subtyping\";\n\nexport type ConstraintSet = Record<string, Constraint>;\n\nexport function constraintSetMeet(\n  first: ConstraintSet,\n  second: ConstraintSet,\n): ConstraintSet | undefined {\n  const names = [...new Set([...Object.keys(first), ...Object.keys(second)]).values()];\n  const constraintSet = Object.fromEntries(\n    names.map((name) => [\n      name,\n      constraintMeet(first[name] ?? TopConstraint, second[name] ?? TopConstraint),\n    ]),\n  );\n\n  if (Object.values(constraintSet).some((constraint) => constraint === undefined)) {\n    return undefined;\n  }\n  return constraintSet as ConstraintSet;\n}\n\nexport function constraintSetsMeet(constraintSets: ConstraintSet[]) {\n  return constraintSets.reduce(constraintSetMeet, {});\n}\n\nexport function areConstraintsSatisfiable(constraints: ConstraintSet) {\n  return Object.values(constraints).every(isConstraintSatisfiable);\n}\n\nconst NoMinimalSubstitution = {};\n\n/**\n * Computes a minimal (most informative) solution for `constraints` on `type`.\n */\nexport function computeMinimalSubstitution(\n  constraints: ConstraintSet,\n  type: Type,\n): TypeSubstitution | undefined {\n  if (!areConstraintsSatisfiable(constraints)) return undefined;\n\n  for (const typeVar of typeVarsFreeIn(type)) {\n    constraints[typeVar] ??= {\n      constraint: \"subtype\",\n      lowerBound: Never,\n      upperBound: Any,\n    };\n  }\n\n  try {\n    return mapValues(constraints, (constraint, name): Type => {\n      if (constraint.constraint === \"untyped\") return Untyped;\n\n      // TODO: Handle equality constraints for bounded quantification\n      if (constraint.constraint === \"equal\") throw \"TODO\";\n\n      const variance = varianceForTypeVar(type, name);\n      switch (variance) {\n        case \"constant\":\n        case \"covariant\":\n          return constraint.lowerBound;\n        case \"contravariant\":\n          return constraint.upperBound;\n        case \"invariant\":\n          // Design choice: Return a non-best type that is reasonable in most cases.\n          // This may mean that inference produces a less specific type than may be obtained\n          // by manual annotations.\n          // However, in practice, this does not seem to be much of an issue.\n          //\n          // Typed Racket appears to make a similar design tradeoff.\n          // e.g.,\n          //\n          //   (: mklst (All (X) (X -> (MListof X))))\n          //   (define (mklst x) (mcons x null))\n          //\n          //   (: mkempty (All (X) (-> (MListof X))))\n          //   (define (mkempty) null)\n          //\n          //   (define l1 (mklst 1)) ; (:print-type l1) gives (MListof Integer)\n          //   (define l2 (mkempty)) ; (:print-type l2) gives (MListof Any)\n          //\n          // where local type inference succeeds, even though the `MListof` type constructor\n          // is invariant in its parameter.\n          //\n          // For a deeper exploration of the issue at hand, see the technical report\n          // \"How good is local type inference?\" by Hosoya and Pierce [https://repository.upenn.edu/handle/20.500.14332/7082],\n          // especially sections 3.2 and 4.1.\n          return constraint.lowerBound;\n      }\n    });\n  } catch (error) {\n    if (error === NoMinimalSubstitution) return undefined;\n    throw error;\n  }\n}\n\ntype TypeVarVariance = \"constant\" | \"covariant\" | \"contravariant\" | \"invariant\";\n\nfunction negateVariance(variance: TypeVarVariance): TypeVarVariance {\n  switch (variance) {\n    case \"constant\":\n    case \"invariant\":\n      return variance;\n    case \"covariant\":\n      return \"contravariant\";\n    case \"contravariant\":\n      return \"covariant\";\n  }\n}\n\nfunction zeroVariance(variance: TypeVarVariance): TypeVarVariance {\n  switch (variance) {\n    case \"constant\":\n      return variance;\n    case \"invariant\":\n    case \"covariant\":\n    case \"contravariant\":\n      return \"invariant\";\n  }\n}\n\nfunction signAdjustVariance(variance: TypeVarVariance, sign: TypeParamVariance): TypeVarVariance {\n  switch (sign) {\n    case \"covariant\":\n      return variance;\n    case \"contravariant\":\n      return negateVariance(variance);\n    case \"invariant\":\n      return zeroVariance(variance);\n  }\n}\n\nfunction varianceForTypeVar(type: Type, typeVarName: string): TypeVarVariance {\n  if (isTypeVarSlot(type)) {\n    return \"constant\";\n  } else if (isTypeVar(type)) {\n    return type.var === typeVarName ? \"covariant\" : \"constant\";\n  } else if (isForallType(type)) {\n    if (isTypeVarBoundBy(typeVarName, type)) {\n      // Shadowed\n      return \"constant\";\n    }\n    return varianceForTypeVar(type.body, typeVarName);\n  } else {\n    const signs = typeParamVariance(type);\n    const typeArgVariances = (type.of ?? [])\n      .map((typeArg) => varianceForTypeVar(typeArg, typeVarName))\n      .map((variance, index) => signAdjustVariance(variance, signs[index]!));\n\n    const hasCovariantArg = typeArgVariances.includes(\"covariant\");\n    const hasContravariantArg = typeArgVariances.includes(\"contravariant\");\n    const hasInvariantArg = typeArgVariances.includes(\"invariant\");\n\n    if (hasInvariantArg || (hasCovariantArg && hasContravariantArg)) {\n      return \"invariant\";\n    } else if (hasCovariantArg) {\n      return \"covariant\";\n    } else if (hasContravariantArg) {\n      return \"contravariant\";\n    } else {\n      return \"constant\";\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}