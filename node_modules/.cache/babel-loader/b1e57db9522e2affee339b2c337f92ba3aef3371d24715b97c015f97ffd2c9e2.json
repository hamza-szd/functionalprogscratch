{"ast":null,"code":"// Syntactically flattened Datum type\n// For expression parsing\nexport function flattenDatum(datum){return datum.kind===\"List\"?flattenListOrQuotedDatum(datum):datum;}export function flattenListOrQuotedDatum(list){var _list$heads$,_list$heads$2;if(((_list$heads$=list.heads[0])===null||_list$heads$===void 0?void 0:_list$heads$.kind)===\"Symbol\"&&((_list$heads$2=list.heads[0])===null||_list$heads$2===void 0?void 0:_list$heads$2.value)===\"quote\"){if(list.heads.length!==2){throw\"'quote' requires exactly one datum\";}return{kind:\"quote\",value:list.heads[1]};}return flattenListDatum(list);}export function flattenListDatum(list){const heads=list.heads.map(flattenDatum);if(!list.tail){return{kind:\"List\",heads};}if(list.tail.kind!==\"List\"){throw\"non-list expressions cannot appear after '.' in this context\";}return{kind:\"List\",heads:[...heads,...flattenListDatum(list.tail).heads]};}","map":{"version":3,"names":["flattenDatum","datum","kind","flattenListOrQuotedDatum","list","_list$heads$","_list$heads$2","heads","value","length","flattenListDatum","map","tail"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/datum/flattened.ts"],"sourcesContent":["// Syntactically flattened Datum type\n// For expression parsing\n\nimport { BoolDatum, Datum, ListDatum, NumberDatum, StringDatum, SymbolDatum } from \"./datum\";\n\nexport type FlattenedDatum =\n  | BoolDatum\n  | NumberDatum\n  | StringDatum\n  | SymbolDatum\n  | FlattenedListDatum\n  | QuotedDatum;\n\nexport type FlattenedListDatum = {\n  kind: \"List\";\n  heads: FlattenedDatum[];\n};\nexport type QuotedDatum = {\n  kind: \"quote\";\n  value: Datum;\n};\n\nexport function flattenDatum(datum: Datum): FlattenedDatum {\n  return datum.kind === \"List\" ? flattenListOrQuotedDatum(datum) : datum;\n}\n\nexport function flattenListOrQuotedDatum(list: ListDatum): FlattenedListDatum | QuotedDatum {\n  if (list.heads[0]?.kind === \"Symbol\" && list.heads[0]?.value === \"quote\") {\n    if (list.heads.length !== 2) {\n      throw \"'quote' requires exactly one datum\";\n    }\n\n    return {\n      kind: \"quote\",\n      value: list.heads[1]!,\n    };\n  }\n\n  return flattenListDatum(list);\n}\n\nexport function flattenListDatum(list: ListDatum): FlattenedListDatum {\n  const heads = list.heads.map(flattenDatum);\n\n  if (!list.tail) {\n    return {\n      kind: \"List\",\n      heads,\n    };\n  }\n\n  if (list.tail.kind !== \"List\") {\n    throw \"non-list expressions cannot appear after '.' in this context\";\n  }\n\n  return {\n    kind: \"List\",\n    heads: [...heads, ...flattenListDatum(list.tail).heads],\n  };\n}\n"],"mappings":"AAAA;AACA;AAqBA,MAAO,SAAS,CAAAA,YAAYA,CAACC,KAAY,CAAkB,CACzD,MAAO,CAAAA,KAAK,CAACC,IAAI,GAAK,MAAM,CAAGC,wBAAwB,CAACF,KAAK,CAAC,CAAGA,KAAK,CACxE,CAEA,MAAO,SAAS,CAAAE,wBAAwBA,CAACC,IAAe,CAAoC,KAAAC,YAAA,CAAAC,aAAA,CAC1F,GAAI,EAAAD,YAAA,CAAAD,IAAI,CAACG,KAAK,CAAC,CAAC,CAAC,UAAAF,YAAA,iBAAbA,YAAA,CAAeH,IAAI,IAAK,QAAQ,EAAI,EAAAI,aAAA,CAAAF,IAAI,CAACG,KAAK,CAAC,CAAC,CAAC,UAAAD,aAAA,iBAAbA,aAAA,CAAeE,KAAK,IAAK,OAAO,CAAE,CACxE,GAAIJ,IAAI,CAACG,KAAK,CAACE,MAAM,GAAK,CAAC,CAAE,CAC3B,KAAM,oCAAoC,CAC5C,CAEA,MAAO,CACLP,IAAI,CAAE,OAAO,CACbM,KAAK,CAAEJ,IAAI,CAACG,KAAK,CAAC,CAAC,CACrB,CAAC,CACH,CAEA,MAAO,CAAAG,gBAAgB,CAACN,IAAI,CAAC,CAC/B,CAEA,MAAO,SAAS,CAAAM,gBAAgBA,CAACN,IAAe,CAAsB,CACpE,KAAM,CAAAG,KAAK,CAAGH,IAAI,CAACG,KAAK,CAACI,GAAG,CAACX,YAAY,CAAC,CAE1C,GAAI,CAACI,IAAI,CAACQ,IAAI,CAAE,CACd,MAAO,CACLV,IAAI,CAAE,MAAM,CACZK,KACF,CAAC,CACH,CAEA,GAAIH,IAAI,CAACQ,IAAI,CAACV,IAAI,GAAK,MAAM,CAAE,CAC7B,KAAM,8DAA8D,CACtE,CAEA,MAAO,CACLA,IAAI,CAAE,MAAM,CACZK,KAAK,CAAE,CAAC,GAAGA,KAAK,CAAE,GAAGG,gBAAgB,CAACN,IAAI,CAACQ,IAAI,CAAC,CAACL,KAAK,CACxD,CAAC,CACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}