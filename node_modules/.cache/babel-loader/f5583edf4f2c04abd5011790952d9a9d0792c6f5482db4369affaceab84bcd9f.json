{"ast":null,"code":"import _classPrivateFieldLooseBase from\"/Users/hamzashahzad/Desktop/resume_projects/sparkground/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";import _classPrivateFieldLooseKey from\"/Users/hamzashahzad/Desktop/resume_projects/sparkground/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";import{keyBy,zipWith}from\"lodash\";import{InitialEnvironment,makeEnv,mergeEnvs}from\"../editor/library/environments\";import{extendIndexPath,isHole,nodeAtIndexPath}from\"../editor/trees/tree\";import{getIdentifier,getPrettyName}from\"../expr/expr\";import{Defines}from\"./defines\";import{checkCallAgainstTypeSignature}from\"./dynamic-type\";import{listValueAsVector,valueAsBool}from\"./value\";import{ErrorsByIndexPath}from\"../expr/errors\";import{collect,withIndices}from\"../util\";export function evalFully(evaluator,fromState){try{return evalFullyOrThrow(evaluator,fromState);}catch(error){console.error(error);}}function evalFullyOrThrow(evaluator,state){return elaborate(evaluator,evaluator.eval(state));}export function elaborate(evaluator,generator){let{done,value}=generator.next();while(!done){const state=value;({done,value}=generator.next(evalFullyOrThrow(evaluator,state)));}return value;}/** Call-by-value evaluator */var _eval_=/*#__PURE__*/_classPrivateFieldLooseKey(\"eval_\");var _get=/*#__PURE__*/_classPrivateFieldLooseKey(\"get\");export class Evaluator{constructor(){let{baseEnv,defines}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};Object.defineProperty(this,_get,{value:_get2});Object.defineProperty(this,_eval_,{value:_eval_2});this.baseEnv=void 0;this.env=void 0;this.defines=void 0;this.components=[];this.indexPath=void 0;this.errors=new ErrorsByIndexPath();this.baseEnv=baseEnv!==null&&baseEnv!==void 0?baseEnv:InitialEnvironment;this.env={...this.baseEnv};this.defines=defines!==null&&defines!==void 0?defines:new Defines();}addDefines(rootIndexPaths){for(const rootIndexPath of rootIndexPaths){try{const root=nodeAtIndexPath(rootIndexPath);switch(root.kind){case\"struct\":this.addStruct(root,rootIndexPath);break;case\"define\":this.addDefine(root,rootIndexPath);break;}}catch(error){// TODO: Remove this try/catch once eval() is changed to not throw any errors\nconsole.error(error);}}}addDefine(define,indexPath){const prevIndexPath=this.indexPath;if(indexPath)this.indexPath=indexPath;const defineBodyIndexPath=this.indexPath?extendIndexPath(this.indexPath,1):undefined;const this_=this;this.defines.add(getIdentifier(define.name),function*(){return{value:yield*this_.eval({expr:define.value,indexPath:defineBodyIndexPath})};});this.indexPath=prevIndexPath;}addStruct(struct,indexPath){const prevIndexPath=this.indexPath;if(indexPath)this.indexPath=indexPath;// Constructor\nthis.defines.add(getIdentifier(struct.name),function*(){return{value:{kind:\"fn\",signature:struct.fields.map(fieldName=>({name:getPrettyName(fieldName)})),*body(args){return{kind:\"List\",heads:[{kind:\"Symbol\",value:getIdentifier(struct.name)},...args]};}}};},{typeAnnotation:isHole(struct.name)?undefined:struct.name.type,bodyArgHints:struct.fields.map(name=>getPrettyName(name))});// Field accessors\nthis.defines.addAll(struct.fields.map((fieldName,fieldIndex)=>[getIdentifier(fieldName),function*(){return{value:{kind:\"fn\",signature:[{name:\"structure\",type:\"List\"}],*body(args){const[struct]=args;const vector=listValueAsVector(struct);if(!vector){throw{tag:\"ImproperList\",functionName:getPrettyName(fieldName),argValue:struct};}const fieldValue=vector[fieldIndex+1];if(!fieldValue){throw{tag:\"WrongStructType\",structName:getPrettyName(fieldName)};}return fieldValue;}}};}]));this.indexPath=prevIndexPath;}/**\n   * Evaluates `expr` down to a value.\n   *\n   * This method exists for unit testing; use the separate `evalFully` function otherwise.\n   */evalFully(expr){let fromState=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};try{return evalFullyOrThrow(this,{...fromState,expr});}catch(error){if(!this.indexPath){// Throw for unit tests\nthrow error;}else{console.error(error);return;}}}*eval(fromState){const{expr,indexPath,index,env,extendEnv}=fromState;const prevEnv=this.env;if(env)this.env=mergeEnvs(this.baseEnv,env);if(extendEnv)this.env=mergeEnvs(this.env,extendEnv);const prevIndexPath=this.indexPath;if(indexPath)this.indexPath=indexPath;if(index!==undefined&&this.indexPath){this.indexPath=extendIndexPath(this.indexPath,index);}let result;try{result=yield*_classPrivateFieldLooseBase(this,_eval_)[_eval_](expr);}catch(error){if(typeof error===\"object\"&&\"tag\"in error&&this.indexPath){this.errors.add(this.indexPath,error);}// FIXME: Don't just rethrow; abort execution\nthrow error;}this.env=prevEnv;this.indexPath=prevIndexPath;return result;}*call(fn,args){var _fn$env;checkCallAgainstTypeSignature(args,fn.signature);let callEnv=(_fn$env=fn.env)!==null&&_fn$env!==void 0?_fn$env:{};for(let i=0;i<args.length&&i<fn.signature.length;++i){const{name}=fn.signature[i];const value=args[i];callEnv=mergeEnvs(callEnv,{[name]:{name,cell:{value}}});}let result;if(typeof fn.body===\"function\"){// Builtin\nresult=yield*fn.body(args,this);}else{result=yield{expr:fn.body,indexPath:fn.indexPath,env:callEnv};}return result;}}function*_eval_2(expr){switch(expr.kind){case\"Number\":case\"Boolean\":case\"String\":case\"Symbol\":case\"List\":if(isHole(expr)){throw{tag:\"HoleEval\"};}return expr;case\"var\":{const cell=yield*_classPrivateFieldLooseBase(this,_get)[_get](expr.id);if(!cell){throw{tag:\"UnboundVariable\",name:expr.id};}if(cell===\"circular\"){throw{tag:\"CircularDependency\",name:expr.id};}if(!cell.value){throw{tag:\"UninitializedVariable\",name:expr.id};}return cell.value;}case\"call\":{const{called,args}=expr;const calledValue=yield{expr:called,index:0};if(calledValue.kind!==\"fn\"){throw{tag:\"CallToNonFunction\",called:calledValue};}const argValues=yield*collect(args.map((arg,index)=>({expr:arg,index:index+1})));return yield*this.call(calledValue,argValues);}case\"struct\":this.addStruct(expr);return{kind:\"List\",heads:[]};case\"define\":this.addDefine(expr);return{kind:\"List\",heads:[]};case\"let\":{const values=yield*collect(expr.bindings.map((_ref,index)=>{let[,value]=_ref;return{expr:value,index:2*index+1};}));const valueBindings=zipWith(expr.bindings,values,(_ref2,value)=>{let[name]=_ref2;return{name:name.id,cell:{value}};});return yield{expr:expr.body,index:2*expr.bindings.length,extendEnv:makeEnv(valueBindings)};}case\"letrec\":{const valueBindings=keyBy(expr.bindings.map(_ref3=>{let[name]=_ref3;return{name:name.id,cell:{}};}),_ref4=>{let{name}=_ref4;return name;});for(const[[name,value],index]of withIndices(expr.bindings)){const binding=valueBindings[name.id];binding.cell.value=yield{expr:value,index:2*index+1,extendEnv:makeEnv([binding])};}return yield{expr:expr.body,index:2*expr.bindings.length,extendEnv:makeEnv(Object.values(valueBindings))};}case\"lambda\":return{kind:\"fn\",signature:expr.params.map(param=>({name:param.id// TODO: type and variadic?\n})),body:expr.body,indexPath:this.indexPath?extendIndexPath(this.indexPath,expr.params.length+1):undefined,env:this.env};case\"sequence\":{const{exprs}=expr;let result={kind:\"List\",heads:[]};for(const[expr,index]of withIndices(exprs)){result=yield{expr,index};}return result;}case\"and\":{if(!expr.args.length)return{kind:\"Boolean\",value:true};let args=[...expr.args];console.log(JSON.stringify(args));let value;let index=0;do{const arg=args.shift();value=yield{expr:arg,index:index++};}while(args.length&&valueAsBool(value));return value;}case\"or\":{if(!expr.args.length)return{kind:\"Boolean\",value:false};let args=[...expr.args];let value;let index=0;do{const arg=args.shift();value=yield{expr:arg,index:index++};}while(args.length&&!valueAsBool(value));return value;}case\"if\":{const condition=yield{expr:expr.if,index:0};if(valueAsBool(condition)){return yield{expr:expr.then,index:1};}else{return yield{expr:expr.else,index:2};}}case\"cond\":case\"name-binding\":case\"type\":throw\"TODO\";}}function*_get2(name){var _this$env$name$cell,_this$env$name;return(_this$env$name$cell=(_this$env$name=this.env[name])===null||_this$env$name===void 0?void 0:_this$env$name.cell)!==null&&_this$env$name$cell!==void 0?_this$env$name$cell:yield*this.defines.get(name);}","map":{"version":3,"names":["keyBy","zipWith","InitialEnvironment","makeEnv","mergeEnvs","extendIndexPath","isHole","nodeAtIndexPath","getIdentifier","getPrettyName","Defines","checkCallAgainstTypeSignature","listValueAsVector","valueAsBool","ErrorsByIndexPath","collect","withIndices","evalFully","evaluator","fromState","evalFullyOrThrow","error","console","state","elaborate","eval","generator","done","value","next","_eval_","_classPrivateFieldLooseKey","_get","Evaluator","constructor","baseEnv","defines","arguments","length","undefined","Object","defineProperty","_get2","_eval_2","env","components","indexPath","errors","addDefines","rootIndexPaths","rootIndexPath","root","kind","addStruct","addDefine","define","prevIndexPath","defineBodyIndexPath","this_","add","name","expr","struct","signature","fields","map","fieldName","body","args","heads","typeAnnotation","type","bodyArgHints","addAll","fieldIndex","vector","tag","functionName","argValue","fieldValue","structName","index","extendEnv","prevEnv","result","_classPrivateFieldLooseBase","call","fn","_fn$env","callEnv","i","cell","id","called","calledValue","argValues","arg","values","bindings","_ref","valueBindings","_ref2","_ref3","_ref4","binding","params","param","exprs","log","JSON","stringify","shift","condition","if","then","else","_this$env$name$cell","_this$env$name","get"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/evaluator/evaluate.ts"],"sourcesContent":["import { keyBy, zipWith } from \"lodash\";\nimport {\n  Binding,\n  Cell,\n  Environment,\n  InitialEnvironment,\n  makeEnv,\n  mergeEnvs,\n} from \"../editor/library/environments\";\nimport { TreeIndexPath, extendIndexPath, isHole, nodeAtIndexPath } from \"../editor/trees/tree\";\nimport { Define, Expr, NameBinding, Struct, getIdentifier, getPrettyName } from \"../expr/expr\";\nimport { Defines } from \"./defines\";\nimport { DynamicParamSignature, checkCallAgainstTypeSignature } from \"./dynamic-type\";\nimport { FnValue, ListValue, Value, listValueAsVector, valueAsBool } from \"./value\";\nimport { SparkgroundComponent } from \"./component\";\nimport { ErrorsByIndexPath } from \"../expr/errors\";\nimport {\n  CallToNonFunction,\n  CircularDependency,\n  HoleEval,\n  ImproperList,\n  RuntimeError,\n  UnboundVariable,\n  UninitializedVariable,\n  WrongStructType,\n} from \"./errors\";\nimport { collect, withIndices } from \"../util\";\n\nexport type EvalState = {\n  expr: Expr;\n  indexPath?: TreeIndexPath;\n  index?: number;\n  env?: Environment;\n  extendEnv?: Environment;\n};\n\nexport type EvalStateGenerator<ReturnValue = Value> = Generator<\n  /* yields */ EvalState,\n  /* returns */ ReturnValue,\n  /* accepts */ Value\n>;\n\nexport interface EvaluatorInterface {\n  components: SparkgroundComponent[];\n\n  eval(fromState: EvalState): EvalStateGenerator;\n  call(fn: FnValue, args: Value[]): EvalStateGenerator;\n}\n\nexport function evalFully(evaluator: EvaluatorInterface, fromState: EvalState): Value | undefined {\n  try {\n    return evalFullyOrThrow(evaluator, fromState);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nfunction evalFullyOrThrow(evaluator: EvaluatorInterface, state: EvalState) {\n  return elaborate(evaluator, evaluator.eval(state));\n}\n\nexport function elaborate(evaluator: EvaluatorInterface, generator: EvalStateGenerator) {\n  let { done, value } = generator.next();\n  while (!done) {\n    const state = value as EvalState;\n    ({ done, value } = generator.next(evalFullyOrThrow(evaluator, state)));\n  }\n\n  return value as Value;\n}\n/** Call-by-value evaluator */\nexport class Evaluator implements EvaluatorInterface {\n  baseEnv: Environment;\n  env: Environment;\n  defines: Defines;\n  components: SparkgroundComponent[] = [];\n\n  indexPath?: TreeIndexPath;\n  errors: ErrorsByIndexPath<RuntimeError> = new ErrorsByIndexPath();\n\n  constructor({\n    baseEnv,\n    defines,\n  }: {\n    baseEnv?: Environment;\n    defines?: Defines;\n  } = {}) {\n    this.baseEnv = baseEnv ?? InitialEnvironment;\n    this.env = { ...this.baseEnv };\n    this.defines = defines ?? new Defines();\n  }\n\n  addDefines(rootIndexPaths: TreeIndexPath[]) {\n    for (const rootIndexPath of rootIndexPaths) {\n      try {\n        const root = nodeAtIndexPath(rootIndexPath);\n        switch (root.kind) {\n          case \"struct\":\n            this.addStruct(root, rootIndexPath);\n            break;\n          case \"define\":\n            this.addDefine(root, rootIndexPath);\n            break;\n        }\n      } catch (error) {\n        // TODO: Remove this try/catch once eval() is changed to not throw any errors\n        console.error(error);\n      }\n    }\n  }\n\n  addDefine(define: Define, indexPath?: TreeIndexPath): void {\n    const prevIndexPath = this.indexPath;\n    if (indexPath) this.indexPath = indexPath;\n\n    const defineBodyIndexPath = this.indexPath ? extendIndexPath(this.indexPath, 1) : undefined;\n    const this_ = this;\n    this.defines.add(getIdentifier(define.name), function* (): EvalStateGenerator<Cell<Value>> {\n      return { value: yield* this_.eval({ expr: define.value, indexPath: defineBodyIndexPath }) };\n    });\n\n    this.indexPath = prevIndexPath;\n  }\n\n  addStruct(struct: Struct, indexPath?: TreeIndexPath): void {\n    const prevIndexPath = this.indexPath;\n    if (indexPath) this.indexPath = indexPath;\n\n    // Constructor\n    this.defines.add(\n      getIdentifier(struct.name),\n      function* (): EvalStateGenerator<Cell<FnValue>> {\n        return {\n          value: {\n            kind: \"fn\",\n            signature: struct.fields.map(\n              (fieldName): DynamicParamSignature => ({ name: getPrettyName(fieldName) }),\n            ),\n            *body(args: Value[]): EvalStateGenerator {\n              return {\n                kind: \"List\",\n                heads: [{ kind: \"Symbol\", value: getIdentifier(struct.name) }, ...args],\n              };\n            },\n          },\n        };\n      },\n      {\n        typeAnnotation: isHole(struct.name) ? undefined : struct.name.type,\n        bodyArgHints: struct.fields.map((name) => getPrettyName(name)),\n      },\n    );\n\n    // Field accessors\n    this.defines.addAll(\n      struct.fields.map((fieldName, fieldIndex) => [\n        getIdentifier(fieldName),\n        function* (): EvalStateGenerator<Cell<FnValue>> {\n          return {\n            value: {\n              kind: \"fn\",\n              signature: [{ name: \"structure\", type: \"List\" }],\n              *body(args: Value[]): EvalStateGenerator {\n                const [struct] = args as [ListValue];\n\n                const vector = listValueAsVector(struct);\n                if (!vector) {\n                  throw {\n                    tag: \"ImproperList\",\n                    functionName: getPrettyName(fieldName),\n                    argValue: struct,\n                  } satisfies ImproperList;\n                }\n\n                const fieldValue = vector[fieldIndex + 1];\n                if (!fieldValue) {\n                  throw {\n                    tag: \"WrongStructType\",\n                    structName: getPrettyName(fieldName),\n                  } satisfies WrongStructType;\n                }\n\n                return fieldValue;\n              },\n            },\n          };\n        },\n      ]),\n    );\n\n    this.indexPath = prevIndexPath;\n  }\n\n  /**\n   * Evaluates `expr` down to a value.\n   *\n   * This method exists for unit testing; use the separate `evalFully` function otherwise.\n   */\n  evalFully(expr: Expr, fromState: Omit<EvalState, \"expr\"> = {}): Value | undefined {\n    try {\n      return evalFullyOrThrow(this, { ...fromState, expr });\n    } catch (error) {\n      if (!this.indexPath) {\n        // Throw for unit tests\n        throw error;\n      } else {\n        console.error(error);\n        return;\n      }\n    }\n  }\n\n  *eval(fromState: EvalState): EvalStateGenerator {\n    const { expr, indexPath, index, env, extendEnv } = fromState;\n\n    const prevEnv = this.env;\n    if (env) this.env = mergeEnvs(this.baseEnv, env);\n    if (extendEnv) this.env = mergeEnvs(this.env, extendEnv);\n\n    const prevIndexPath = this.indexPath;\n    if (indexPath) this.indexPath = indexPath;\n    if (index !== undefined && this.indexPath) {\n      this.indexPath = extendIndexPath(this.indexPath, index);\n    }\n\n    let result: Value;\n    try {\n      result = yield* this.#eval_(expr);\n    } catch (error) {\n      if (typeof error === \"object\" && \"tag\" in error && this.indexPath) {\n        this.errors.add(this.indexPath, error);\n      }\n      // FIXME: Don't just rethrow; abort execution\n      throw error;\n    }\n\n    this.env = prevEnv;\n    this.indexPath = prevIndexPath;\n    return result;\n  }\n\n  *#eval_(expr: Expr): EvalStateGenerator {\n    switch (expr.kind) {\n      case \"Number\":\n      case \"Boolean\":\n      case \"String\":\n      case \"Symbol\":\n      case \"List\":\n        if (isHole(expr)) {\n          throw { tag: \"HoleEval\" } satisfies HoleEval;\n        }\n        return expr;\n\n      case \"var\": {\n        const cell = yield* this.#get(expr.id);\n\n        if (!cell) {\n          throw { tag: \"UnboundVariable\", name: expr.id } satisfies UnboundVariable;\n        }\n        if (cell === \"circular\") {\n          throw { tag: \"CircularDependency\", name: expr.id } satisfies CircularDependency;\n        }\n        if (!cell.value) {\n          throw { tag: \"UninitializedVariable\", name: expr.id } satisfies UninitializedVariable;\n        }\n\n        return cell.value;\n      }\n\n      case \"call\": {\n        const { called, args } = expr;\n\n        const calledValue = yield { expr: called, index: 0 };\n        if (calledValue.kind !== \"fn\") {\n          throw { tag: \"CallToNonFunction\", called: calledValue } satisfies CallToNonFunction;\n        }\n\n        const argValues = yield* collect(\n          args.map((arg, index): EvalState => ({ expr: arg, index: index + 1 })),\n        );\n\n        return yield* this.call(calledValue, argValues);\n      }\n\n      case \"struct\":\n        this.addStruct(expr);\n        return { kind: \"List\", heads: [] };\n\n      case \"define\":\n        this.addDefine(expr);\n        return { kind: \"List\", heads: [] };\n\n      case \"let\": {\n        const values = yield* collect(\n          expr.bindings.map(\n            ([, value], index): EvalState => ({ expr: value, index: 2 * index + 1 }),\n          ),\n        );\n        const valueBindings = zipWith(expr.bindings, values, ([name], value) => ({\n          name: (name as NameBinding).id,\n          cell: { value },\n        }));\n\n        return yield {\n          expr: expr.body,\n          index: 2 * expr.bindings.length,\n          extendEnv: makeEnv(valueBindings),\n        };\n      }\n\n      case \"letrec\": {\n        const valueBindings = keyBy(\n          expr.bindings.map(\n            ([name]): Binding<Value> => ({\n              name: (name as NameBinding).id,\n              cell: {},\n            }),\n          ),\n          ({ name }) => name,\n        );\n\n        for (const [[name, value], index] of withIndices(expr.bindings)) {\n          const binding = valueBindings[(name as NameBinding).id]!;\n          binding.cell.value = yield {\n            expr: value,\n            index: 2 * index + 1,\n            extendEnv: makeEnv([binding]),\n          };\n        }\n\n        return yield {\n          expr: expr.body,\n          index: 2 * expr.bindings.length,\n          extendEnv: makeEnv(Object.values(valueBindings)),\n        };\n      }\n\n      case \"lambda\":\n        return {\n          kind: \"fn\",\n          signature: expr.params.map((param) => ({\n            name: (param as NameBinding).id,\n            // TODO: type and variadic?\n          })),\n          body: expr.body,\n          indexPath: this.indexPath\n            ? extendIndexPath(this.indexPath, expr.params.length + 1)\n            : undefined,\n          env: this.env,\n        };\n\n      case \"sequence\": {\n        const { exprs } = expr;\n\n        let result: Value = { kind: \"List\", heads: [] };\n        for (const [expr, index] of withIndices(exprs)) {\n          result = yield { expr, index };\n        }\n\n        return result;\n      }\n\n      case \"and\": {\n        if (!expr.args.length) return { kind: \"Boolean\", value: true };\n\n        let args = [...expr.args];\n        console.log(JSON.stringify(args));\n        let value: Value;\n        let index = 0;\n        do {\n          const arg = args.shift()!;\n          value = yield { expr: arg, index: index++ };\n        } while (args.length && valueAsBool(value));\n\n        return value;\n      }\n\n      case \"or\": {\n        if (!expr.args.length) return { kind: \"Boolean\", value: false };\n\n        let args = [...expr.args];\n        let value: Value;\n        let index = 0;\n        do {\n          const arg = args.shift()!;\n          value = yield { expr: arg, index: index++ };\n        } while (args.length && !valueAsBool(value));\n\n        return value;\n      }\n\n      case \"if\": {\n        const condition = yield { expr: expr.if, index: 0 };\n        if (valueAsBool(condition)) {\n          return yield { expr: expr.then, index: 1 };\n        } else {\n          return yield { expr: expr.else, index: 2 };\n        }\n      }\n\n      case \"cond\":\n      case \"name-binding\":\n      case \"type\":\n        throw \"TODO\";\n    }\n  }\n\n  *call(fn: FnValue, args: Value[]): EvalStateGenerator {\n    checkCallAgainstTypeSignature(args, fn.signature);\n\n    let callEnv = fn.env ?? {};\n    for (let i = 0; i < args.length && i < fn.signature.length; ++i) {\n      const { name } = fn.signature[i]!;\n      const value = args[i]!;\n\n      callEnv = mergeEnvs(callEnv, {\n        [name]: {\n          name,\n          cell: { value },\n        },\n      });\n    }\n\n    let result: Value;\n    if (typeof fn.body === \"function\") {\n      // Builtin\n      result = yield* fn.body(args, this);\n    } else {\n      result = yield { expr: fn.body, indexPath: fn.indexPath, env: callEnv };\n    }\n\n    return result;\n  }\n\n  *#get(name: string): EvalStateGenerator<Cell<Value> | undefined | \"circular\"> {\n    return this.env[name]?.cell ?? (yield* this.defines.get(name));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}