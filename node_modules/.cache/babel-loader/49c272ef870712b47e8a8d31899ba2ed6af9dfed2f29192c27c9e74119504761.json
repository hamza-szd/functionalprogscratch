{"ast":null,"code":"import{isEqual}from\"lodash\";import{serializeExpr}from\"./serialize\";import{Parser as DatumParser}from\"../../datum/parse\";import{Untyped,hasTag,isForallType,isTypeNameHole,isTypeVar,isTypeVarSlot}from\"../../typechecker/type\";import{Parser as TypeParser}from\"../../typechecker/parse\";import{Parser as ExprParser}from\"../../expr/parse\";import{flattenDatum}from\"../../datum/flattened\";import{extendEnv}from\"../library/environments\";import{serializeType}from\"../../typechecker/serialize\";export function isAtomic(node){return[\"Number\",\"Boolean\",\"String\",\"Symbol\",\"var\"].includes(node.kind);}export function children(node){switch(node.kind){// Datum\ncase\"List\":return[node.tail,...node.heads];// Type\ncase\"type\":{const type=node.type;const wrapTypeAsExpr=type=>({kind:\"type\",type});if(!type||isTypeVar(type)||isTypeVarSlot(type)){return[];}else if(isForallType(type)){return[...type.forall.map(wrapTypeAsExpr),wrapTypeAsExpr(type.body)];}else{return type.of?type.of.map(wrapTypeAsExpr):[];}}// Expr\ncase\"name-binding\":return node.type?[{kind:\"type\",type:node.type}]:[];case\"call\":return[node.called,...node.args];case\"struct\":return[node.name,...node.fields];case\"define\":return[node.name,node.value];case\"let\":case\"letrec\":return[...node.bindings.flat(1),node.body];case\"lambda\":return[...node.params,hole,...(node.returnType?[{kind:\"type\",type:node.returnType}]:[]),node.body];case\"sequence\":return node.exprs;case\"and\":case\"or\":return[...node.args];case\"if\":return[node.if,node.then,node.else];case\"cond\":throw\"TODO\";//   return [expr.cases];\ndefault:if(!isAtomic(node))throw`programmer error: unhandled expr kind ${node.kind}!`;return[];}}export function childAtIndex(node,index){return children(node)[index];}export function setChildAtIndex(node,index,newChild){switch(node.kind){// Datum\ncase\"List\":if(index===0)node.tail=asDatum(newChild);else node.heads[index-1]=asDatum(newChild);break;// Type\ncase\"type\":{const type=node.type;if(isTypeVar(type)||isTypeVarSlot(type))break;if(isForallType(type)){if(index<type.forall.length)type.forall[index]=asTypeVarSlot(newChild);else type.body=asType(newChild);}else{// Concrete type\ntype.of??=[];type.of[index]=asType(newChild);}break;}// Expr\ncase\"name-binding\":if(index===0)node.type=asType(newChild);break;case\"call\":if(index===0)node.called=newChild;else node.args[index-1]=newChild;break;case\"struct\":if(index===0)node.name=asVarSlot(newChild);else node.fields[index-1]=asVarSlot(newChild);node.fields=node.fields.filter(field=>!isHole(field));break;case\"define\":if(index===0)node.name=asVarSlot(newChild);if(index===1)node.value=newChild;break;case\"let\":case\"letrec\":if(index<2*node.bindings.length){const binding=node.bindings[Math.floor(index/2)];binding[index%2]=newChild;}if(index===2*node.bindings.length)node.body=newChild;break;case\"lambda\":if(index<=node.params.length)node.params[index]=asVarSlot(newChild);if(index===node.params.length+1)node.returnType=asType(newChild);if(index===node.params.length+2)node.body=newChild;node.params=node.params.filter(param=>!isHole(param));break;case\"sequence\":node.exprs[index]=newChild;break;case\"and\":case\"or\":node.args[index]=newChild;break;case\"if\":if(index===0)node.if=newChild;if(index===1)node.then=newChild;if(index===2)node.else=newChild;break;case\"cond\":throw\"TODO\";default:if(!isAtomic(node))throw`programmer error: unhandled expr kind ${node.kind}!`;break;}}function asDatum(node){switch(node.kind){// Datum\ncase\"Boolean\":case\"Number\":case\"String\":case\"Symbol\":case\"List\":return node;// Expr\ndefault:// Serialize the expression, then parse it back\n// Bit of a hack, but it should work\nreturn DatumParser.parseToDatum(serializeExpr(node));}}function asType(node){switch(node.kind){// Type\ncase\"type\":return node.type;// Expr\ndefault:if(isHole(node))return Untyped;// Serialize the expression, then parse it back\n// Bit of a hack, but it should work\nreturn TypeParser.parseToType(serializeExpr(node));}}function asTypeVarSlot(node){const type=asType(node);if(isTypeVarSlot(type))return type;// Once again: Serialize the expression, then parse it back\nreturn new TypeParser().parseTypeVarSlot(flattenDatum(DatumParser.parseToDatum(serializeType(type))));}function asVarSlot(node){if(isHole(node)||node.kind===\"name-binding\")return node;// Once again: Serialize the expression, then parse it back\nreturn new ExprParser().parseVarSlot(flattenDatum(asDatum(node)));}export const hole={kind:\"Symbol\",value:\"·\"};export function isHole(node){return(node===null||node===void 0?void 0:node.kind)===\"Symbol\"&&node.value===\"·\";}export function isHoleForEditor(node){return isHole(node)||(node===null||node===void 0?void 0:node.kind)===\"type\"&&(isTypeNameHole(node.type)||hasTag(node.type,Untyped.tag));}export function rootIndexPath(tree){return{tree,path:[]};}export function extendIndexPath(_ref,extension){let{tree,path}=_ref;return{tree,path:[...path,extension]};}export function parentIndexPath(_ref2){let{tree,path}=_ref2;return{tree,path:path.slice(0,-1)};}export function nodeAtIndexPath(_ref3){let{tree:{root},path}=_ref3;const[origRoot,origPath]=[root,path];path=[...path];while(path.length){const index=path.shift();const child=childAtIndex(root,index);if(!child){if(path.length){console.error(\"invalid index path for tree\",origRoot,origPath);throw\"invalid index path for tree\";}else{return hole;}}root=child;}return root;}export function isAncestor(ancestor,descendant){if(descendant.tree!==ancestor.tree)return false;if(descendant.path.length<=ancestor.path.length)return false;for(let i=0;i<ancestor.path.length;++i){if(descendant.path[i]!==ancestor.path[i])return false;}return true;}export function isSameOrAncestor(ancestor,descendant){return ancestor.tree===descendant.tree&&isEqual(ancestor.path,descendant.path)||isAncestor(ancestor,descendant);}export function referencesToBindingInScope(id,scope){let selfIsBindingExpr=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;const self=nodeAtIndexPath(scope);let selfRef=[];let unshadowedChildren=children(self);switch(self.kind){case\"var\":if(self.id===id){selfRef=[self];}unshadowedChildren=[];break;case\"lambda\":if(!selfIsBindingExpr&&self.params.some(slot=>slot.kind===\"name-binding\"&&slot.id===id)){// Shadowed in every child\nunshadowedChildren=[];}break;case\"let\":case\"letrec\":if(!selfIsBindingExpr&&self.bindings.some(_ref4=>{let[slot]=_ref4;return slot.kind===\"name-binding\"&&slot.id===id;})){// Shadowed in body\nunshadowedChildren.pop();}break;}return[...selfRef,...unshadowedChildren.flatMap((child,childIndex)=>{if(!child)return[];const childIndexPath=extendIndexPath(scope,childIndex);return referencesToBindingInScope(id,childIndexPath,false/* if var is bound again further down the tree, it's shadowing this binding */);})];}/**\n * Returns all unbound (free) variable references in the expression at `root`\n * with contextual bindings in `env`.\n */export function unboundReferences(root){let env=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const parent=nodeAtIndexPath(root);if(parent.kind===\"var\"){return env[parent.id]?[]:[parent];}return children(nodeAtIndexPath(root)).flatMap((child,childIndex)=>{if(!child)return[];const childIndexPath=extendIndexPath(root,childIndex);switch(parent.kind){case\"lambda\":if(childIndex<parent.params.length){return unboundReferences(childIndexPath,env);}else{return unboundReferences(childIndexPath,extendEnv(env,root,parent.params));}case\"define\":return unboundReferences(childIndexPath,extendEnv(env,root,[parent.name]));case\"let\":if(childIndex<2*parent.bindings.length){return unboundReferences(childIndexPath,env);}else{return unboundReferences(childIndexPath,extendEnv(env,root,parent.bindings.map(_ref5=>{let[name]=_ref5;return name;})));}case\"letrec\":return unboundReferences(childIndexPath,extendEnv(env,root,parent.bindings.map(_ref6=>{let[name]=_ref6;return name;})));default:return unboundReferences(childIndexPath,env);}});}","map":{"version":3,"names":["isEqual","serializeExpr","Parser","DatumParser","Untyped","hasTag","isForallType","isTypeNameHole","isTypeVar","isTypeVarSlot","TypeParser","ExprParser","flattenDatum","extendEnv","serializeType","isAtomic","node","includes","kind","children","tail","heads","type","wrapTypeAsExpr","forall","map","body","of","called","args","name","fields","value","bindings","flat","params","hole","returnType","exprs","if","then","else","childAtIndex","index","setChildAtIndex","newChild","asDatum","length","asTypeVarSlot","asType","asVarSlot","filter","field","isHole","binding","Math","floor","param","parseToDatum","parseToType","parseTypeVarSlot","parseVarSlot","isHoleForEditor","tag","rootIndexPath","tree","path","extendIndexPath","_ref","extension","parentIndexPath","_ref2","slice","nodeAtIndexPath","_ref3","root","origRoot","origPath","shift","child","console","error","isAncestor","ancestor","descendant","i","isSameOrAncestor","referencesToBindingInScope","id","scope","selfIsBindingExpr","arguments","undefined","self","selfRef","unshadowedChildren","some","slot","_ref4","pop","flatMap","childIndex","childIndexPath","unboundReferences","env","parent","_ref5","_ref6"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/editor/trees/tree.ts"],"sourcesContent":["import { Tree } from \"./trees\";\nimport { isEqual } from \"lodash\";\nimport { Expr, Hole, TypeExpr, Var, VarSlot } from \"../../expr/expr\";\nimport { Datum } from \"../../datum/datum\";\nimport { serializeExpr } from \"./serialize\";\nimport { Parser as DatumParser } from \"../../datum/parse\";\nimport {\n  Type,\n  TypeVarSlot,\n  Untyped,\n  hasTag,\n  isForallType,\n  isTypeNameHole,\n  isTypeVar,\n  isTypeVarSlot,\n} from \"../../typechecker/type\";\nimport { Parser as TypeParser } from \"../../typechecker/parse\";\nimport { Parser as ExprParser } from \"../../expr/parse\";\nimport { flattenDatum } from \"../../datum/flattened\";\nimport { Environment, extendEnv } from \"../library/environments\";\nimport { serializeType } from \"../../typechecker/serialize\";\n\nexport function isAtomic(node: Expr) {\n  return ([\"Number\", \"Boolean\", \"String\", \"Symbol\", \"var\"] satisfies Expr[\"kind\"][]).includes(\n    node.kind as any,\n  );\n}\n\nexport function children(node: Expr): (Expr | undefined)[] {\n  switch (node.kind) {\n    // Datum\n    case \"List\":\n      return [node.tail, ...node.heads];\n\n    // Type\n    case \"type\": {\n      const type = node.type;\n\n      const wrapTypeAsExpr = (type: Type): TypeExpr => ({ kind: \"type\", type });\n\n      if (!type || isTypeVar(type) || isTypeVarSlot(type)) {\n        return [];\n      } else if (isForallType(type)) {\n        return [...type.forall.map(wrapTypeAsExpr), wrapTypeAsExpr(type.body)];\n      } else {\n        return type.of ? type.of.map(wrapTypeAsExpr) : [];\n      }\n    }\n\n    // Expr\n    case \"name-binding\":\n      return node.type ? [{ kind: \"type\", type: node.type }] : [];\n    case \"call\":\n      return [node.called, ...node.args];\n    case \"struct\":\n      return [node.name, ...node.fields];\n    case \"define\":\n      return [node.name, node.value];\n    case \"let\":\n    case \"letrec\":\n      return [...node.bindings.flat(1), node.body];\n    case \"lambda\":\n      return [\n        ...node.params,\n        hole,\n        ...(node.returnType ? [{ kind: \"type\", type: node.returnType } satisfies TypeExpr] : []),\n        node.body,\n      ];\n    case \"sequence\":\n      return node.exprs;\n    case \"and\":\n    case \"or\":\n      return [...node.args];\n    case \"if\":\n      return [node.if, node.then, node.else];\n    case \"cond\":\n      throw \"TODO\";\n    //   return [expr.cases];\n    default:\n      if (!isAtomic(node)) throw `programmer error: unhandled expr kind ${node.kind}!`;\n      return [];\n  }\n}\n\nexport function childAtIndex(node: Expr, index: number): Expr | undefined {\n  return children(node)[index];\n}\n\nexport function setChildAtIndex(node: Expr, index: number, newChild: Expr): void {\n  switch (node.kind) {\n    // Datum\n    case \"List\":\n      if (index === 0) node.tail = asDatum(newChild);\n      else node.heads[index - 1] = asDatum(newChild);\n      break;\n\n    // Type\n    case \"type\": {\n      const type = node.type;\n      if (isTypeVar(type) || isTypeVarSlot(type)) break;\n\n      if (isForallType(type)) {\n        if (index < type.forall.length) type.forall[index] = asTypeVarSlot(newChild);\n        else type.body = asType(newChild);\n      } else {\n        // Concrete type\n        type.of ??= [];\n        type.of[index] = asType(newChild);\n      }\n      break;\n    }\n\n    // Expr\n    case \"name-binding\":\n      if (index === 0) node.type = asType(newChild);\n      break;\n    case \"call\":\n      if (index === 0) node.called = newChild;\n      else node.args[index - 1] = newChild;\n      break;\n    case \"struct\":\n      if (index === 0) node.name = asVarSlot(newChild);\n      else node.fields[index - 1] = asVarSlot(newChild);\n      node.fields = node.fields.filter((field) => !isHole(field));\n      break;\n    case \"define\":\n      if (index === 0) node.name = asVarSlot(newChild);\n      if (index === 1) node.value = newChild;\n      break;\n    case \"let\":\n    case \"letrec\":\n      if (index < 2 * node.bindings.length) {\n        const binding = node.bindings[Math.floor(index / 2)]!;\n        binding[index % 2] = newChild;\n      }\n      if (index === 2 * node.bindings.length) node.body = newChild;\n      break;\n    case \"lambda\":\n      if (index <= node.params.length) node.params[index] = asVarSlot(newChild);\n      if (index === node.params.length + 1) node.returnType = asType(newChild);\n      if (index === node.params.length + 2) node.body = newChild;\n      node.params = node.params.filter((param) => !isHole(param));\n      break;\n    case \"sequence\":\n      node.exprs[index] = newChild;\n      break;\n    case \"and\":\n    case \"or\":\n      node.args[index] = newChild;\n      break;\n    case \"if\":\n      if (index === 0) node.if = newChild;\n      if (index === 1) node.then = newChild;\n      if (index === 2) node.else = newChild;\n      break;\n    case \"cond\":\n      throw \"TODO\";\n\n    default:\n      if (!isAtomic(node)) throw `programmer error: unhandled expr kind ${node.kind}!`;\n      break;\n  }\n}\n\nfunction asDatum(node: Expr): Datum {\n  switch (node.kind) {\n    // Datum\n    case \"Boolean\":\n    case \"Number\":\n    case \"String\":\n    case \"Symbol\":\n    case \"List\":\n      return node;\n\n    // Expr\n    default:\n      // Serialize the expression, then parse it back\n      // Bit of a hack, but it should work\n      return DatumParser.parseToDatum(serializeExpr(node));\n  }\n}\n\nfunction asType(node: Expr): Type {\n  switch (node.kind) {\n    // Type\n    case \"type\":\n      return node.type;\n\n    // Expr\n    default:\n      if (isHole(node)) return Untyped;\n\n      // Serialize the expression, then parse it back\n      // Bit of a hack, but it should work\n      return TypeParser.parseToType(serializeExpr(node));\n  }\n}\n\nfunction asTypeVarSlot(node: Expr): TypeVarSlot {\n  const type = asType(node);\n\n  if (isTypeVarSlot(type)) return type;\n\n  // Once again: Serialize the expression, then parse it back\n  return new TypeParser().parseTypeVarSlot(\n    flattenDatum(DatumParser.parseToDatum(serializeType(type))),\n  );\n}\n\nfunction asVarSlot(node: Expr): VarSlot {\n  if (isHole(node) || node.kind === \"name-binding\") return node;\n\n  // Once again: Serialize the expression, then parse it back\n  return new ExprParser().parseVarSlot(flattenDatum(asDatum(node)));\n}\n\nexport const hole: Hole = { kind: \"Symbol\", value: \"·\" };\nexport function isHole(node: Expr | undefined): node is Hole {\n  return node?.kind === \"Symbol\" && node.value === \"·\";\n}\nexport function isHoleForEditor(node: Expr | undefined): boolean {\n  return (\n    isHole(node) ||\n    (node?.kind === \"type\" && (isTypeNameHole(node.type) || hasTag(node.type, Untyped.tag)))\n  );\n}\n\nexport type TreeIndexPath = {\n  tree: Tree;\n  path: number[];\n};\nexport function rootIndexPath(tree: Tree): TreeIndexPath {\n  return {\n    tree,\n    path: [],\n  };\n}\nexport function extendIndexPath({ tree, path }: TreeIndexPath, extension: number) {\n  return {\n    tree,\n    path: [...path, extension],\n  };\n}\nexport function parentIndexPath({ tree, path }: TreeIndexPath) {\n  return {\n    tree,\n    path: path.slice(0, -1),\n  };\n}\nexport function nodeAtIndexPath({ tree: { root }, path }: TreeIndexPath): Expr {\n  const [origRoot, origPath] = [root, path];\n\n  path = [...path];\n  while (path.length) {\n    const index = path.shift()!;\n\n    const child = childAtIndex(root, index);\n    if (!child) {\n      if (path.length) {\n        console.error(\"invalid index path for tree\", origRoot, origPath);\n        throw \"invalid index path for tree\";\n      } else {\n        return hole;\n      }\n    }\n\n    root = child;\n  }\n\n  return root;\n}\nexport function isAncestor(ancestor: TreeIndexPath, descendant: TreeIndexPath): boolean {\n  if (descendant.tree !== ancestor.tree) return false;\n  if (descendant.path.length <= ancestor.path.length) return false;\n\n  for (let i = 0; i < ancestor.path.length; ++i) {\n    if (descendant.path[i] !== ancestor.path[i]) return false;\n  }\n  return true;\n}\nexport function isSameOrAncestor(ancestor: TreeIndexPath, descendant: TreeIndexPath): boolean {\n  return (\n    (ancestor.tree === descendant.tree && isEqual(ancestor.path, descendant.path)) ||\n    isAncestor(ancestor, descendant)\n  );\n}\n\nexport function referencesToBindingInScope(\n  id: string,\n  scope: TreeIndexPath,\n  selfIsBindingExpr = true,\n): Var[] {\n  const self = nodeAtIndexPath(scope);\n\n  let selfRef: [Var] | [] = [];\n  let unshadowedChildren: (Expr | undefined)[] = children(self);\n  switch (self.kind) {\n    case \"var\":\n      if (self.id === id) {\n        selfRef = [self];\n      }\n      unshadowedChildren = [];\n      break;\n    case \"lambda\":\n      if (\n        !selfIsBindingExpr &&\n        self.params.some((slot) => slot.kind === \"name-binding\" && slot.id === id)\n      ) {\n        // Shadowed in every child\n        unshadowedChildren = [];\n      }\n      break;\n    case \"let\":\n    case \"letrec\":\n      if (\n        !selfIsBindingExpr &&\n        self.bindings.some(([slot]) => slot.kind === \"name-binding\" && slot.id === id)\n      ) {\n        // Shadowed in body\n        unshadowedChildren.pop();\n      }\n      break;\n  }\n\n  return [\n    ...selfRef,\n    ...unshadowedChildren.flatMap((child, childIndex) => {\n      if (!child) return [];\n      const childIndexPath = extendIndexPath(scope, childIndex);\n      return referencesToBindingInScope(\n        id,\n        childIndexPath,\n        false /* if var is bound again further down the tree, it's shadowing this binding */,\n      );\n    }),\n  ];\n}\n\n/**\n * Returns all unbound (free) variable references in the expression at `root`\n * with contextual bindings in `env`.\n */\nexport function unboundReferences(root: TreeIndexPath, env: Environment = {}): Var[] {\n  const parent = nodeAtIndexPath(root);\n\n  if (parent.kind === \"var\") {\n    return env[parent.id] ? [] : [parent];\n  }\n\n  return children(nodeAtIndexPath(root)).flatMap((child, childIndex): Var[] => {\n    if (!child) return [];\n    const childIndexPath = extendIndexPath(root, childIndex);\n\n    switch (parent.kind) {\n      case \"lambda\":\n        if (childIndex < parent.params.length) {\n          return unboundReferences(childIndexPath, env);\n        } else {\n          return unboundReferences(childIndexPath, extendEnv(env, root, parent.params));\n        }\n\n      case \"define\":\n        return unboundReferences(childIndexPath, extendEnv(env, root, [parent.name]));\n\n      case \"let\":\n        if (childIndex < 2 * parent.bindings.length) {\n          return unboundReferences(childIndexPath, env);\n        } else {\n          return unboundReferences(\n            childIndexPath,\n            extendEnv(\n              env,\n              root,\n              parent.bindings.map(([name]) => name),\n            ),\n          );\n        }\n\n      case \"letrec\":\n        return unboundReferences(\n          childIndexPath,\n          extendEnv(\n            env,\n            root,\n            parent.bindings.map(([name]) => name),\n          ),\n        );\n\n      default:\n        return unboundReferences(childIndexPath, env);\n    }\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}