{"ast":null,"code":"import{isEqual}from\"lodash\";import{Any,Never,Untyped,hasTag,isForallType,isTypeNameBinding,isTypeVar,isTypeVarSlot,typeParamMap}from\"../type\";import{constraintSetMeet,constraintSetsMeet}from\"./constraint-set\";import{isSubtype,typeParamVariance}from\"../subtyping\";import{typeVarsFreeIn}from\"../type-substitution\";export function generateConstraints(// V\nvarNamesInScope,// X\nconstrainVarNames,// S\nsubtype,// T\nsupertype){if(isTypeVarSlot(subtype)||isTypeVarSlot(supertype))return;if(hasTag(subtype,Untyped.tag)||hasTag(supertype,Untyped.tag)){// Gradual typing rules\nconst other=hasTag(subtype,Untyped.tag)?supertype:subtype;// Variables of other are \"poisoned\" by untyped bound\nreturn Object.fromEntries(typeVarsFreeIn(other).map(varName=>[varName,{constraint:\"untyped\"}]));}else if(isSubtype(subtype,supertype,true)){// Nothing to enforce!\n// CG-Refl falls into here\nreturn{};}if(isTypeVar(subtype)){if(constrainVarNames.includes(subtype.var)){// CG-Upper\nreturn{[subtype.var]:{constraint:\"subtype\",lowerBound:Never,upperBound:eliminateDown(varNamesInScope,supertype)}};}}else if(isTypeVar(supertype)){if(constrainVarNames.includes(supertype.var)){if(hasTag(subtype,Untyped.tag)){// Gradual typing: Variable is \"poisoned\" by untyped bound\nreturn{[supertype.var]:{constraint:\"untyped\"}};}// CG-Lower\nreturn{[supertype.var]:{constraint:\"subtype\",lowerBound:eliminateUp(varNamesInScope,subtype),upperBound:Any}};}}else if(isForallType(subtype)||isForallType(supertype)){if(!(isForallType(subtype)&&isForallType(supertype))||!isEqual(subtype.forall,supertype.forall)){return;}// FIXME: Somehow rename type vars if they appear in varNames or constrainVarNames\nreturn generateConstraints([...varNamesInScope,...subtype.forall.flatMap(slot=>isTypeNameBinding(slot)?[slot.id]:[])],constrainVarNames,subtype.body,supertype.body);}else if(subtype.tag===Never.tag||supertype.tag===Any.tag){// CG-Bot, CG-Top\nreturn{};}else if(subtype.tag===supertype.tag){const signs=typeParamVariance(subtype);const constraintSets=signs.map((sign,index)=>{const subtypeArg=subtype.of[index];const supertypeArg=supertype.of[index];switch(sign){case\"covariant\":// prettier-ignore\nreturn generateConstraints(varNamesInScope,constrainVarNames,subtypeArg,supertypeArg);case\"contravariant\":// prettier-ignore\nreturn generateConstraints(varNamesInScope,constrainVarNames,supertypeArg,subtypeArg);case\"invariant\":{// prettier-ignore\nconst positiveSet=generateConstraints(varNamesInScope,constrainVarNames,subtypeArg,supertypeArg);// prettier-ignore\nconst negativeSet=generateConstraints(varNamesInScope,constrainVarNames,supertypeArg,subtypeArg);if(positiveSet===undefined||negativeSet===undefined){return undefined;}return constraintSetMeet(positiveSet,negativeSet);}}});if(constraintSets.some(set=>set===undefined))return;return constraintSetsMeet(constraintSets);}}function eliminate(variables,type,promoteToType,eliminateSame,eliminateOpposite){if(isTypeVarSlot(type))return type;if(isTypeVar(type)){return variables.includes(type.var)?promoteToType:type;}if(isForallType(type)){// FIXME: Somehow rename type vars\nreturn eliminateSame(variables,type.body);}const signs=typeParamVariance(type);return typeParamMap(type,(t,index)=>{switch(signs[index]){case\"covariant\":return eliminateSame(variables,t);case\"contravariant\":return eliminateOpposite(variables,t);case\"invariant\":return eliminateFixed(variables,t);}});}export function eliminateUp(variables,type){return eliminate(variables,type,Any,eliminateUp,eliminateDown);}export function eliminateDown(variables,type){return eliminate(variables,type,Never,eliminateDown,eliminateUp);}export function eliminateFixed(variables,type){if(isTypeVarSlot(type))return type;if(isTypeVar(type)){if(variables.includes(type.var)){// Impossible to eliminate; give up\n// TODO: Probably should be an error...\nreturn Untyped;}else{return type;}}if(isForallType(type)){// FIXME: Somehow rename type vars\nreturn eliminateFixed(variables,type.body);}return typeParamMap(type,t=>eliminateFixed(variables,t));}","map":{"version":3,"names":["isEqual","Any","Never","Untyped","hasTag","isForallType","isTypeNameBinding","isTypeVar","isTypeVarSlot","typeParamMap","constraintSetMeet","constraintSetsMeet","isSubtype","typeParamVariance","typeVarsFreeIn","generateConstraints","varNamesInScope","constrainVarNames","subtype","supertype","tag","other","Object","fromEntries","map","varName","constraint","includes","var","lowerBound","upperBound","eliminateDown","eliminateUp","forall","flatMap","slot","id","body","signs","constraintSets","sign","index","subtypeArg","of","supertypeArg","positiveSet","negativeSet","undefined","some","set","eliminate","variables","type","promoteToType","eliminateSame","eliminateOpposite","t","eliminateFixed"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/typechecker/constraints/constraint-gen.ts"],"sourcesContent":["import { isEqual } from \"lodash\";\nimport {\n  Any,\n  Never,\n  Type,\n  Untyped,\n  hasTag,\n  isForallType,\n  isTypeNameBinding,\n  isTypeVar,\n  isTypeVarSlot,\n  typeParamMap,\n} from \"../type\";\nimport { ConstraintSet, constraintSetMeet, constraintSetsMeet } from \"./constraint-set\";\nimport { isSubtype, typeParamVariance } from \"../subtyping\";\nimport { typeVarsFreeIn } from \"../type-substitution\";\nimport { Constraint } from \"./constraint\";\n\nexport function generateConstraints(\n  // V\n  varNamesInScope: string[],\n  // X\n  constrainVarNames: string[],\n  // S\n  subtype: Type,\n  // T\n  supertype: Type,\n): ConstraintSet | undefined {\n  if (isTypeVarSlot(subtype) || isTypeVarSlot(supertype)) return;\n\n  if (hasTag(subtype, Untyped.tag) || hasTag(supertype, Untyped.tag)) {\n    // Gradual typing rules\n\n    const other = hasTag(subtype, Untyped.tag) ? supertype : subtype;\n\n    // Variables of other are \"poisoned\" by untyped bound\n    return Object.fromEntries(\n      typeVarsFreeIn(other).map((varName): [string, Constraint] => [\n        varName,\n        { constraint: \"untyped\" },\n      ]),\n    );\n  } else if (isSubtype(subtype, supertype, true)) {\n    // Nothing to enforce!\n    // CG-Refl falls into here\n    return {};\n  }\n\n  if (isTypeVar(subtype)) {\n    if (constrainVarNames.includes(subtype.var)) {\n      // CG-Upper\n      return {\n        [subtype.var]: {\n          constraint: \"subtype\",\n          lowerBound: Never,\n          upperBound: eliminateDown(varNamesInScope, supertype),\n        },\n      };\n    }\n  } else if (isTypeVar(supertype)) {\n    if (constrainVarNames.includes(supertype.var)) {\n      if (hasTag(subtype, Untyped.tag)) {\n        // Gradual typing: Variable is \"poisoned\" by untyped bound\n        return { [supertype.var]: { constraint: \"untyped\" } };\n      }\n\n      // CG-Lower\n      return {\n        [supertype.var]: {\n          constraint: \"subtype\",\n          lowerBound: eliminateUp(varNamesInScope, subtype),\n          upperBound: Any,\n        },\n      };\n    }\n  } else if (isForallType(subtype) || isForallType(supertype)) {\n    if (\n      !(isForallType(subtype) && isForallType(supertype)) ||\n      !isEqual(subtype.forall, supertype.forall)\n    ) {\n      return;\n    }\n\n    // FIXME: Somehow rename type vars if they appear in varNames or constrainVarNames\n    return generateConstraints(\n      [\n        ...varNamesInScope,\n        ...subtype.forall.flatMap((slot) => (isTypeNameBinding(slot) ? [slot.id] : [])),\n      ],\n      constrainVarNames,\n      subtype.body,\n      supertype.body,\n    );\n  } else if (subtype.tag === Never.tag || supertype.tag === Any.tag) {\n    // CG-Bot, CG-Top\n    return {};\n  } else if (subtype.tag === supertype.tag) {\n    const signs = typeParamVariance(subtype);\n\n    const constraintSets: (ConstraintSet | undefined)[] = signs.map(\n      (sign, index): ConstraintSet | undefined => {\n        const subtypeArg = subtype.of![index]!;\n        const supertypeArg = supertype.of![index]!;\n\n        switch (sign) {\n          case \"covariant\":\n            // prettier-ignore\n            return generateConstraints(varNamesInScope, constrainVarNames, subtypeArg, supertypeArg);\n          case \"contravariant\":\n            // prettier-ignore\n            return generateConstraints(varNamesInScope, constrainVarNames, supertypeArg, subtypeArg);\n          case \"invariant\": {\n            // prettier-ignore\n            const positiveSet = generateConstraints(varNamesInScope, constrainVarNames, subtypeArg, supertypeArg);\n            // prettier-ignore\n            const negativeSet = generateConstraints(varNamesInScope, constrainVarNames, supertypeArg, subtypeArg);\n\n            if (positiveSet === undefined || negativeSet === undefined) {\n              return undefined;\n            }\n\n            return constraintSetMeet(positiveSet, negativeSet);\n          }\n        }\n      },\n    );\n\n    if (constraintSets.some((set) => set === undefined)) return;\n\n    return constraintSetsMeet(constraintSets as ConstraintSet[]);\n  }\n}\n\nfunction eliminate(\n  variables: string[],\n  type: Type,\n  promoteToType: Type,\n  eliminateSame: (variables: string[], type: Type) => Type,\n  eliminateOpposite: (variables: string[], type: Type) => Type,\n): Type {\n  if (isTypeVarSlot(type)) return type;\n\n  if (isTypeVar(type)) {\n    return variables.includes(type.var) ? promoteToType : type;\n  }\n\n  if (isForallType(type)) {\n    // FIXME: Somehow rename type vars\n    return eliminateSame(variables, type.body);\n  }\n\n  const signs = typeParamVariance(type);\n  return typeParamMap(type, (t, index): Type => {\n    switch (signs[index]!) {\n      case \"covariant\":\n        return eliminateSame(variables, t);\n      case \"contravariant\":\n        return eliminateOpposite(variables, t);\n      case \"invariant\":\n        return eliminateFixed(variables, t);\n    }\n  });\n}\n\nexport function eliminateUp(variables: string[], type: Type) {\n  return eliminate(variables, type, Any, eliminateUp, eliminateDown);\n}\n\nexport function eliminateDown(variables: string[], type: Type) {\n  return eliminate(variables, type, Never, eliminateDown, eliminateUp);\n}\n\nexport function eliminateFixed(variables: string[], type: Type): Type {\n  if (isTypeVarSlot(type)) return type;\n\n  if (isTypeVar(type)) {\n    if (variables.includes(type.var)) {\n      // Impossible to eliminate; give up\n      // TODO: Probably should be an error...\n      return Untyped;\n    } else {\n      return type;\n    }\n  }\n\n  if (isForallType(type)) {\n    // FIXME: Somehow rename type vars\n    return eliminateFixed(variables, type.body);\n  }\n\n  return typeParamMap(type, (t): Type => eliminateFixed(variables, t));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}