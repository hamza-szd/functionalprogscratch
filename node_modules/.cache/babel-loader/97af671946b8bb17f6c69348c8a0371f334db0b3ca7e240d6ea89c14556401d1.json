{"ast":null,"code":"import{flattenDatum}from\"../datum/flattened\";import{Parser as DatumParser}from\"../datum/parse\";export class Parser{static parseToType(source){return new Parser().parseType(flattenDatum(DatumParser.parseToDatum(source)));}parseType(datum){switch(datum.kind){case\"Symbol\":return datum.value.startsWith(\"#\")?{var:datum.value.slice(1)}:{tag:datum.value};case\"Boolean\":return{var:datum.value?\"t\":\"f\"};case\"List\":const tagDatum=datum.heads[0];if((tagDatum===null||tagDatum===void 0?void 0:tagDatum.kind)!==\"Symbol\"){throw\"type arguments can only be applied to type constructor names\";}const tag=tagDatum.value;if(tag===\"All\"){return this.parseForallType(datum);}else{const argData=datum.heads.slice(1);const args=argData.map(head=>this.parseType(head));return{tag,of:args};}default:throw\"invalid type expression\";}}parseForallType(datum){this.requireLength(datum,3);const varsList=datum.heads[1];if(varsList.kind!==\"List\"){throw\"expecting type variable list\";}const forall=varsList.heads.map(varDatum=>this.parseTypeVarSlot(varDatum));const body=this.parseType(datum.heads[2]);return{forall,body};}parseTypeVarSlot(datum){if(datum.kind===\"Boolean\")return{kind:\"type-name-binding\",id:datum.value?\"t\":\"f\"};if(datum.kind!==\"Symbol\")throw\"expected identifier\";if(datum.value===\"·\")return{kind:\"type-name-hole\"};return{kind:\"type-name-binding\",id:datum.value.startsWith(\"#\")?datum.value.slice(1):datum.value};}requireLength(list,length){if(list.heads.length!==length){throw`expecting list of length ${length}, but actual length is ${list.heads.length}`;}}}","map":{"version":3,"names":["flattenDatum","Parser","DatumParser","parseToType","source","parseType","parseToDatum","datum","kind","value","startsWith","var","slice","tag","tagDatum","heads","parseForallType","argData","args","map","head","of","requireLength","varsList","forall","varDatum","parseTypeVarSlot","body","id","list","length"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/typechecker/parse.ts"],"sourcesContent":["import { FlattenedDatum, FlattenedListDatum, flattenDatum } from \"../datum/flattened\";\nimport { Parser as DatumParser } from \"../datum/parse\";\nimport { ForallType, Type, TypeVarSlot } from \"./type\";\n\nexport class Parser {\n  static parseToType(source: string): Type {\n    return new Parser().parseType(flattenDatum(DatumParser.parseToDatum(source)));\n  }\n\n  parseType(datum: FlattenedDatum): Type {\n    switch (datum.kind) {\n      case \"Symbol\":\n        return datum.value.startsWith(\"#\") ? { var: datum.value.slice(1) } : { tag: datum.value };\n\n      case \"Boolean\":\n        return { var: datum.value ? \"t\" : \"f\" };\n\n      case \"List\":\n        const tagDatum = datum.heads[0];\n        if (tagDatum?.kind !== \"Symbol\") {\n          throw \"type arguments can only be applied to type constructor names\";\n        }\n        const tag = tagDatum.value;\n\n        if (tag === \"All\") {\n          return this.parseForallType(datum);\n        } else {\n          const argData = datum.heads.slice(1);\n          const args = argData.map((head) => this.parseType(head));\n\n          return {\n            tag,\n            of: args,\n          };\n        }\n\n      default:\n        throw \"invalid type expression\";\n    }\n  }\n\n  parseForallType(datum: FlattenedListDatum): ForallType {\n    this.requireLength(datum, 3);\n\n    const varsList = datum.heads[1]!;\n    if (varsList.kind !== \"List\") {\n      throw \"expecting type variable list\";\n    }\n\n    const forall: TypeVarSlot[] = varsList.heads.map((varDatum) => this.parseTypeVarSlot(varDatum));\n    const body = this.parseType(datum.heads[2]!);\n\n    return {\n      forall,\n      body,\n    };\n  }\n\n  parseTypeVarSlot(datum: FlattenedDatum): TypeVarSlot {\n    if (datum.kind === \"Boolean\") return { kind: \"type-name-binding\", id: datum.value ? \"t\" : \"f\" };\n\n    if (datum.kind !== \"Symbol\") throw \"expected identifier\";\n\n    if (datum.value === \"·\") return { kind: \"type-name-hole\" };\n    return {\n      kind: \"type-name-binding\",\n      id: datum.value.startsWith(\"#\") ? datum.value.slice(1) : datum.value,\n    };\n  }\n\n  private requireLength(list: FlattenedListDatum, length: number) {\n    if (list.heads.length !== length) {\n      throw `expecting list of length ${length}, but actual length is ${list.heads.length}`;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}