{"ast":null,"code":"import{isEqual}from\"lodash\";import{Any,Never}from\"../type\";import{isSubtype,typeJoin,typeMeet}from\"../subtyping\";/** Identity with respect to constraintMeet. */export const TopConstraint={constraint:\"subtype\",lowerBound:Never,upperBound:Any};export function constraintMeet(first,second){if(first.constraint===\"untyped\")return first;if(second.constraint===\"untyped\")return second;if(second.constraint===\"subtype\"){[first,second]=[second,first];}// If either is a subtype constraint, now the first one is. (Meet is commutative)\nif(first.constraint===\"equal\"){// Both are equality constraints.\nreturn isEqual(first.type,second.type)?first:undefined;}else if(second.constraint===\"equal\"){// First is a subtype constraint, and second is an equality constraint.\nreturn isSubtype(first.lowerBound,second.type)&&isSubtype(second.type,first.upperBound)?second:undefined;}else{// Both are subtype constraints.\nreturn{constraint:\"subtype\",lowerBound:typeJoin(first.lowerBound,second.lowerBound),upperBound:typeMeet(first.upperBound,second.upperBound)};}}export function constraintsMeet(constraints){return constraints.reduce(constraintMeet,TopConstraint);}export function isConstraintSatisfiable(constraint){switch(constraint.constraint){case\"equal\":return true;case\"subtype\":return isSubtype(constraint.lowerBound,constraint.upperBound);case\"untyped\":return true;}}","map":{"version":3,"names":["isEqual","Any","Never","isSubtype","typeJoin","typeMeet","TopConstraint","constraint","lowerBound","upperBound","constraintMeet","first","second","type","undefined","constraintsMeet","constraints","reduce","isConstraintSatisfiable"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/typechecker/constraints/constraint.ts"],"sourcesContent":["import { isEqual } from \"lodash\";\nimport { Any, Never, Type } from \"../type\";\nimport { isSubtype, typeJoin, typeMeet } from \"../subtyping\";\n\nexport type Constraint = EqualityConstraint | SubtypeConstraint | UntypedConstraint;\n\nexport type EqualityConstraint = {\n  constraint: \"equal\";\n  type: Type;\n};\n\nexport type SubtypeConstraint = {\n  constraint: \"subtype\";\n  lowerBound: Type;\n  upperBound: Type;\n};\n\nexport type UntypedConstraint = {\n  constraint: \"untyped\";\n};\n\n/** Identity with respect to constraintMeet. */\nexport const TopConstraint: SubtypeConstraint = {\n  constraint: \"subtype\",\n  lowerBound: Never,\n  upperBound: Any,\n};\n\nexport function constraintMeet(first: Constraint, second: Constraint): Constraint | undefined {\n  if (first.constraint === \"untyped\") return first;\n  if (second.constraint === \"untyped\") return second;\n\n  if (second.constraint === \"subtype\") {\n    [first, second] = [second, first];\n  }\n  // If either is a subtype constraint, now the first one is. (Meet is commutative)\n\n  if (first.constraint === \"equal\") {\n    // Both are equality constraints.\n    return isEqual(first.type, (second as EqualityConstraint).type) ? first : undefined;\n  } else if (second.constraint === \"equal\") {\n    // First is a subtype constraint, and second is an equality constraint.\n    return isSubtype(first.lowerBound, second.type) && isSubtype(second.type, first.upperBound)\n      ? second\n      : undefined;\n  } else {\n    // Both are subtype constraints.\n    return {\n      constraint: \"subtype\",\n      lowerBound: typeJoin(first.lowerBound, second.lowerBound),\n      upperBound: typeMeet(first.upperBound, second.upperBound),\n    };\n  }\n}\n\nexport function constraintsMeet(constraints: Constraint[]): Constraint | undefined {\n  return constraints.reduce(constraintMeet, TopConstraint);\n}\n\nexport function isConstraintSatisfiable(constraint: Constraint): boolean {\n  switch (constraint.constraint) {\n    case \"equal\":\n      return true;\n    case \"subtype\":\n      return isSubtype(constraint.lowerBound, constraint.upperBound);\n    case \"untyped\":\n      return true;\n  }\n}\n"],"mappings":"AAAA,OAASA,OAAO,KAAQ,QAAQ,CAChC,OAASC,GAAG,CAAEC,KAAK,KAAc,SAAS,CAC1C,OAASC,SAAS,CAAEC,QAAQ,CAAEC,QAAQ,KAAQ,cAAc,CAmB5D,+CACA,MAAO,MAAM,CAAAC,aAAgC,CAAG,CAC9CC,UAAU,CAAE,SAAS,CACrBC,UAAU,CAAEN,KAAK,CACjBO,UAAU,CAAER,GACd,CAAC,CAED,MAAO,SAAS,CAAAS,cAAcA,CAACC,KAAiB,CAAEC,MAAkB,CAA0B,CAC5F,GAAID,KAAK,CAACJ,UAAU,GAAK,SAAS,CAAE,MAAO,CAAAI,KAAK,CAChD,GAAIC,MAAM,CAACL,UAAU,GAAK,SAAS,CAAE,MAAO,CAAAK,MAAM,CAElD,GAAIA,MAAM,CAACL,UAAU,GAAK,SAAS,CAAE,CACnC,CAACI,KAAK,CAAEC,MAAM,CAAC,CAAG,CAACA,MAAM,CAAED,KAAK,CAAC,CACnC,CACA;AAEA,GAAIA,KAAK,CAACJ,UAAU,GAAK,OAAO,CAAE,CAChC;AACA,MAAO,CAAAP,OAAO,CAACW,KAAK,CAACE,IAAI,CAAGD,MAAM,CAAwBC,IAAI,CAAC,CAAGF,KAAK,CAAGG,SAAS,CACrF,CAAC,IAAM,IAAIF,MAAM,CAACL,UAAU,GAAK,OAAO,CAAE,CACxC;AACA,MAAO,CAAAJ,SAAS,CAACQ,KAAK,CAACH,UAAU,CAAEI,MAAM,CAACC,IAAI,CAAC,EAAIV,SAAS,CAACS,MAAM,CAACC,IAAI,CAAEF,KAAK,CAACF,UAAU,CAAC,CACvFG,MAAM,CACNE,SAAS,CACf,CAAC,IAAM,CACL;AACA,MAAO,CACLP,UAAU,CAAE,SAAS,CACrBC,UAAU,CAAEJ,QAAQ,CAACO,KAAK,CAACH,UAAU,CAAEI,MAAM,CAACJ,UAAU,CAAC,CACzDC,UAAU,CAAEJ,QAAQ,CAACM,KAAK,CAACF,UAAU,CAAEG,MAAM,CAACH,UAAU,CAC1D,CAAC,CACH,CACF,CAEA,MAAO,SAAS,CAAAM,eAAeA,CAACC,WAAyB,CAA0B,CACjF,MAAO,CAAAA,WAAW,CAACC,MAAM,CAACP,cAAc,CAAEJ,aAAa,CAAC,CAC1D,CAEA,MAAO,SAAS,CAAAY,uBAAuBA,CAACX,UAAsB,CAAW,CACvE,OAAQA,UAAU,CAACA,UAAU,EAC3B,IAAK,OAAO,CACV,MAAO,KAAI,CACb,IAAK,SAAS,CACZ,MAAO,CAAAJ,SAAS,CAACI,UAAU,CAACC,UAAU,CAAED,UAAU,CAACE,UAAU,CAAC,CAChE,IAAK,SAAS,CACZ,MAAO,KAAI,CACf,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}