{"ast":null,"code":"import _classPrivateFieldLooseBase from\"/Users/hamzashahzad/Desktop/resume_projects/sparkground/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";import _classPrivateFieldLooseKey from\"/Users/hamzashahzad/Desktop/resume_projects/sparkground/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";import{flattenDatum}from\"../datum/flattened\";import{Parser as DatumParser}from\"../datum/parse\";import{hole,isHole}from\"../editor/trees/tree\";import{parseAttributes}from\"./attributes\";import{Parser as TypeParser}from\"../typechecker/parse\";import{merge}from\"lodash\";var _parsePrimary=/*#__PURE__*/_classPrivateFieldLooseKey(\"parsePrimary\");export class Parser{constructor(){Object.defineProperty(this,_parsePrimary,{value:_parsePrimary2});this.nextAttributes=void 0;}static parseToExprsWithAttributes(source){const parser=new Parser();return DatumParser.parseToDataWithComments(source).flatMap(datum=>{if(datum.kind===\"comment\"){parser.nextAttributes=parseAttributes(datum.text);return[];}return[parser.parsePrimary(flattenDatum(datum))];});}static parseToExprs(source){const parser=new Parser();return DatumParser.parseToData(source).map(datum=>parser.parsePrimary(flattenDatum(datum)));}static parseToExpr(source){return new Parser().parsePrimary(flattenDatum(DatumParser.parseToDatum(source)));}parsePrimary(datum){const attributes=this.nextAttributes;this.nextAttributes=undefined;const primary=_classPrivateFieldLooseBase(this,_parsePrimary)[_parsePrimary](datum);return attributes!==undefined?merge({attributes},primary):primary;}parseCall(datum){const[called,...args]=datum.heads.map(head=>this.parsePrimary(head));return{kind:\"call\",called:called,args};}parseTypeExpr(datum){this.requireLength(datum,2);return{kind:\"type\",type:this.parseType(datum.heads[1])};}parseType(datum){return new TypeParser().parseType(datum);}parseStruct(datum){const name=this.parseVarSlot(datum.heads[1]);const fields=datum.heads.slice(2).map(head=>this.parseVarSlot(head));return{kind:\"struct\",name,fields};}parseDefine(datum){this.requireLength(datum,3);const name=this.parseVarSlot(datum.heads[1]);const value=this.parsePrimary(datum.heads[2]);return{kind:\"define\",name,value};}parseLet(datum){this.requireLength(datum,3);const bindingList=datum.heads[1];if(bindingList.kind!==\"List\"){throw\"expecting binding list\";}const bindings=bindingList.heads.map(binding=>{if(binding.kind!==\"List\"){throw\"expecting binding\";}this.requireLength(binding,2);const name=this.parseVarSlot(binding.heads[0]);const value=this.parsePrimary(binding.heads[1]);return[name,value];});const body=this.parsePrimary(datum.heads[2]);return{kind:\"let\",bindings,body};}parseLetrec(datum){return{...this.parseLet(datum),kind:\"letrec\"};}parseLambda(datum){this.requireLength(datum,3);const bindingList=datum.heads[1];if(bindingList.kind!==\"List\"){throw\"expecting binding list\";}const params=bindingList.heads.map(name=>this.parseVarSlot(name));const body=this.parseSequence(datum.heads.slice(2));const returnTypeIndex=params.findIndex(param=>!isHole(param)&&param.id===\"→\");const returnType=returnTypeIndex!==-1?params.splice(returnTypeIndex,1)[0].type:undefined;return{kind:\"lambda\",params,body,...(returnType?{returnType}:{})};}parseSequence(heads){const exprs=heads.map(head=>this.parsePrimary(head));return{kind:\"sequence\",exprs};}parseAnd(datum){const args=datum.heads.slice(1).map(arg=>this.parsePrimary(arg));return{kind:\"and\",args};}parseOr(datum){const args=datum.heads.slice(1).map(arg=>this.parsePrimary(arg));return{kind:\"or\",args};}parseIf(datum){this.requireLength(datum,4);const if_=this.parsePrimary(datum.heads[1]);const then=this.parsePrimary(datum.heads[2]);const else_=this.parsePrimary(datum.heads[3]);return{kind:\"if\",if:if_,then,else:else_};}parseCond(datum){this.requireLength(datum,2);const caseList=datum.heads[1];if(caseList.kind!==\"List\"){throw\"expecting cond case list\";}const cases=caseList.heads.map(case_=>{if(case_.kind!==\"List\"){throw\"expecting cond case\";}this.requireLength(case_,2);const condition=this.parsePrimary(case_.heads[0]);const value=this.parsePrimary(case_.heads[1]);return[condition,value];});return{kind:\"cond\",cases};}parseVar(datum){if(datum.kind!==\"Symbol\")throw\"expected identifier\";return{kind:\"var\",id:datum.value};}parseVarSlot(datum){let id;let type;if(datum.kind===\"List\"){if(datum.heads.length>2){throw`expecting list of length ${length}, but actual length is ${datum.heads.length}`;}id=this.parseVar(datum.heads[0]).id;if(datum.heads.length>=2)type=this.parseType(datum.heads[1]);}else{id=this.parseVar(datum).id;}if(id===hole.value)return hole;if(type)return{kind:\"name-binding\",id,type};return{kind:\"name-binding\",id};}requireLength(list,length){if(list.heads.length!==length){throw`expecting list of length ${length}, but actual length is ${list.heads.length}`;}}}function _parsePrimary2(datum){switch(datum.kind){case\"Boolean\":case\"Number\":case\"String\":return datum;case\"Symbol\":const symbol=datum.value;switch(symbol){case\"quote\":case\"type\":case\"struct\":case\"define\":case\"let\":case\"letrec\":case\"lambda\":case\"and\":case\"or\":case\"if\":case\"cond\":throw`misplaced keyword '${symbol}'`;default:if(symbol===\"·\")return hole;return{kind:\"var\",id:symbol};}case\"List\":const called=datum.heads[0];if(called.kind===\"Symbol\"){// Determine which syntactic keyword this is, if any\nswitch(called.value){case\"type\":return this.parseTypeExpr(datum);case\"struct\":return this.parseStruct(datum);case\"define\":return this.parseDefine(datum);case\"let\":return this.parseLet(datum);case\"letrec\":return this.parseLetrec(datum);case\"lambda\":return this.parseLambda(datum);case\"and\":return this.parseAnd(datum);case\"or\":return this.parseOr(datum);case\"if\":return this.parseIf(datum);case\"cond\":return this.parseCond(datum);default:return this.parseCall(datum);}}return{kind:\"call\",called:this.parsePrimary(called),args:datum.heads.slice(1).map(head=>this.parsePrimary(head))};case\"quote\":return datum.value;}}","map":{"version":3,"names":["flattenDatum","Parser","DatumParser","hole","isHole","parseAttributes","TypeParser","merge","_parsePrimary","_classPrivateFieldLooseKey","constructor","Object","defineProperty","value","_parsePrimary2","nextAttributes","parseToExprsWithAttributes","source","parser","parseToDataWithComments","flatMap","datum","kind","text","parsePrimary","parseToExprs","parseToData","map","parseToExpr","parseToDatum","attributes","undefined","primary","_classPrivateFieldLooseBase","parseCall","called","args","heads","head","parseTypeExpr","requireLength","type","parseType","parseStruct","name","parseVarSlot","fields","slice","parseDefine","parseLet","bindingList","bindings","binding","body","parseLetrec","parseLambda","params","parseSequence","returnTypeIndex","findIndex","param","id","returnType","splice","exprs","parseAnd","arg","parseOr","parseIf","if_","then","else_","if","else","parseCond","caseList","cases","case_","condition","parseVar","length","list","symbol"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/expr/parse.ts"],"sourcesContent":["import {\n  Define,\n  Expr,\n  Let,\n  Call,\n  Lambda,\n  Sequence,\n  If,\n  Cond,\n  Var,\n  Letrec,\n  TypeExpr,\n  VarSlot,\n  And,\n  Or,\n  Struct,\n  NameBinding,\n} from \"./expr\";\nimport { FlattenedDatum, FlattenedListDatum, flattenDatum } from \"../datum/flattened\";\nimport { Parser as DatumParser } from \"../datum/parse\";\nimport { hole, isHole } from \"../editor/trees/tree\";\nimport { DefinitionAttributes, parseAttributes } from \"./attributes\";\nimport { Parser as TypeParser } from \"../typechecker/parse\";\nimport { merge } from \"lodash\";\nimport { Type } from \"../typechecker/type\";\n\nexport class Parser {\n  static parseToExprsWithAttributes(source: string) {\n    const parser = new Parser();\n    return DatumParser.parseToDataWithComments(source).flatMap((datum) => {\n      if (datum.kind === \"comment\") {\n        parser.nextAttributes = parseAttributes(datum.text);\n        return [];\n      }\n      return [parser.parsePrimary(flattenDatum(datum))];\n    });\n  }\n\n  static parseToExprs(source: string) {\n    const parser = new Parser();\n    return DatumParser.parseToData(source).map((datum) => parser.parsePrimary(flattenDatum(datum)));\n  }\n\n  static parseToExpr(source: string): Expr {\n    return new Parser().parsePrimary(flattenDatum(DatumParser.parseToDatum(source)));\n  }\n\n  private nextAttributes?: DefinitionAttributes;\n\n  parsePrimary(datum: FlattenedDatum): Expr {\n    const attributes = this.nextAttributes;\n    this.nextAttributes = undefined;\n\n    const primary = this.#parsePrimary(datum);\n\n    return attributes !== undefined ? merge({ attributes }, primary) : primary;\n  }\n\n  #parsePrimary(datum: FlattenedDatum): Expr {\n    switch (datum.kind) {\n      case \"Boolean\":\n      case \"Number\":\n      case \"String\":\n        return datum;\n\n      case \"Symbol\":\n        const symbol = datum.value;\n        switch (symbol) {\n          case \"quote\":\n          case \"type\":\n          case \"struct\":\n          case \"define\":\n          case \"let\":\n          case \"letrec\":\n          case \"lambda\":\n          case \"and\":\n          case \"or\":\n          case \"if\":\n          case \"cond\":\n            throw `misplaced keyword '${symbol}'`;\n          default:\n            if (symbol === \"·\") return hole;\n            return { kind: \"var\", id: symbol };\n        }\n\n      case \"List\":\n        const called = datum.heads[0]!;\n        if (called.kind === \"Symbol\") {\n          // Determine which syntactic keyword this is, if any\n\n          switch (called.value) {\n            case \"type\":\n              return this.parseTypeExpr(datum);\n            case \"struct\":\n              return this.parseStruct(datum);\n            case \"define\":\n              return this.parseDefine(datum);\n            case \"let\":\n              return this.parseLet(datum);\n            case \"letrec\":\n              return this.parseLetrec(datum);\n            case \"lambda\":\n              return this.parseLambda(datum);\n            case \"and\":\n              return this.parseAnd(datum);\n            case \"or\":\n              return this.parseOr(datum);\n            case \"if\":\n              return this.parseIf(datum);\n            case \"cond\":\n              return this.parseCond(datum);\n            default:\n              return this.parseCall(datum);\n          }\n        }\n\n        return {\n          kind: \"call\",\n          called: this.parsePrimary(called),\n          args: datum.heads.slice(1).map((head) => this.parsePrimary(head)),\n        };\n\n      case \"quote\":\n        return datum.value;\n    }\n  }\n\n  parseCall(datum: FlattenedListDatum): Call {\n    const [called, ...args] = datum.heads.map((head) => this.parsePrimary(head));\n    return {\n      kind: \"call\",\n      called: called!,\n      args,\n    };\n  }\n\n  parseTypeExpr(datum: FlattenedListDatum): TypeExpr {\n    this.requireLength(datum, 2);\n\n    return {\n      kind: \"type\",\n      type: this.parseType(datum.heads[1]!),\n    };\n  }\n\n  parseType(datum: FlattenedDatum): Type {\n    return new TypeParser().parseType(datum);\n  }\n\n  parseStruct(datum: FlattenedListDatum): Struct {\n    const name = this.parseVarSlot(datum.heads[1]!);\n    const fields = datum.heads.slice(2).map((head) => this.parseVarSlot(head));\n\n    return {\n      kind: \"struct\",\n      name,\n      fields,\n    };\n  }\n\n  parseDefine(datum: FlattenedListDatum): Define {\n    this.requireLength(datum, 3);\n\n    const name = this.parseVarSlot(datum.heads[1]!);\n    const value = this.parsePrimary(datum.heads[2]!);\n\n    return {\n      kind: \"define\",\n      name,\n      value,\n    };\n  }\n\n  parseLet(datum: FlattenedListDatum): Let {\n    this.requireLength(datum, 3);\n\n    const bindingList = datum.heads[1]!;\n    if (bindingList.kind !== \"List\") {\n      throw \"expecting binding list\";\n    }\n\n    const bindings: [name: VarSlot, value: Expr][] = bindingList.heads.map((binding) => {\n      if (binding.kind !== \"List\") {\n        throw \"expecting binding\";\n      }\n      this.requireLength(binding, 2);\n\n      const name = this.parseVarSlot(binding.heads[0]!);\n      const value = this.parsePrimary(binding.heads[1]!);\n\n      return [name, value];\n    });\n\n    const body = this.parsePrimary(datum.heads[2]!);\n\n    return {\n      kind: \"let\",\n      bindings,\n      body,\n    };\n  }\n\n  parseLetrec(datum: FlattenedListDatum): Letrec {\n    return { ...this.parseLet(datum), kind: \"letrec\" };\n  }\n\n  parseLambda(datum: FlattenedListDatum): Lambda {\n    this.requireLength(datum, 3);\n\n    const bindingList = datum.heads[1]!;\n    if (bindingList.kind !== \"List\") {\n      throw \"expecting binding list\";\n    }\n\n    const params: VarSlot[] = bindingList.heads.map((name) => this.parseVarSlot(name));\n    const body = this.parseSequence(datum.heads.slice(2));\n\n    const returnTypeIndex = params.findIndex((param) => !isHole(param) && param.id === \"→\");\n    const returnType =\n      returnTypeIndex !== -1\n        ? (params.splice(returnTypeIndex, 1)[0] as NameBinding).type\n        : undefined;\n\n    return {\n      kind: \"lambda\",\n      params,\n      body,\n      ...(returnType ? { returnType } : {}),\n    };\n  }\n\n  parseSequence(heads: FlattenedDatum[]): Sequence {\n    const exprs = heads.map((head) => this.parsePrimary(head));\n    return { kind: \"sequence\", exprs };\n  }\n\n  parseAnd(datum: FlattenedListDatum): And {\n    const args = datum.heads.slice(1).map((arg) => this.parsePrimary(arg));\n\n    return {\n      kind: \"and\",\n      args,\n    };\n  }\n\n  parseOr(datum: FlattenedListDatum): Or {\n    const args = datum.heads.slice(1).map((arg) => this.parsePrimary(arg));\n\n    return {\n      kind: \"or\",\n      args,\n    };\n  }\n\n  parseIf(datum: FlattenedListDatum): If {\n    this.requireLength(datum, 4);\n\n    const if_ = this.parsePrimary(datum.heads[1]!);\n    const then = this.parsePrimary(datum.heads[2]!);\n    const else_ = this.parsePrimary(datum.heads[3]!);\n\n    return {\n      kind: \"if\",\n      if: if_,\n      then,\n      else: else_,\n    };\n  }\n\n  parseCond(datum: FlattenedListDatum): Cond {\n    this.requireLength(datum, 2);\n\n    const caseList = datum.heads[1]!;\n    if (caseList.kind !== \"List\") {\n      throw \"expecting cond case list\";\n    }\n\n    const cases: [condition: Expr, value: Expr][] = caseList.heads.map((case_) => {\n      if (case_.kind !== \"List\") {\n        throw \"expecting cond case\";\n      }\n      this.requireLength(case_, 2);\n\n      const condition = this.parsePrimary(case_.heads[0]!);\n      const value = this.parsePrimary(case_.heads[1]!);\n\n      return [condition, value];\n    });\n\n    return {\n      kind: \"cond\",\n      cases,\n    };\n  }\n\n  parseVar(datum: FlattenedDatum): Var {\n    if (datum.kind !== \"Symbol\") throw \"expected identifier\";\n    return { kind: \"var\", id: datum.value };\n  }\n\n  parseVarSlot(datum: FlattenedDatum): VarSlot {\n    let id: string;\n    let type: Type | undefined;\n\n    if (datum.kind === \"List\") {\n      if (datum.heads.length > 2) {\n        throw `expecting list of length ${length}, but actual length is ${datum.heads.length}`;\n      }\n      id = this.parseVar(datum.heads[0]!).id;\n      if (datum.heads.length >= 2) type = this.parseType(datum.heads[1]!);\n    } else {\n      id = this.parseVar(datum).id;\n    }\n\n    if (id === hole.value) return hole;\n    if (type) return { kind: \"name-binding\", id, type };\n    return { kind: \"name-binding\", id };\n  }\n\n  private requireLength(list: FlattenedListDatum, length: number) {\n    if (list.heads.length !== length) {\n      throw `expecting list of length ${length}, but actual length is ${list.heads.length}`;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}