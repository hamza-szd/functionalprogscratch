{"ast":null,"code":"import _classPrivateFieldLooseBase from\"/Users/hamzashahzad/Desktop/resume_projects/sparkground/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";import _classPrivateFieldLooseKey from\"/Users/hamzashahzad/Desktop/resume_projects/sparkground/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";import{evalFully,Evaluator}from\"../evaluator/evaluate\";import{nodeAtIndexPath,rootIndexPath}from\"../editor/trees/tree\";var _entryPointIndexPaths=/*#__PURE__*/_classPrivateFieldLooseKey(\"entryPointIndexPaths\");var _evaluator=/*#__PURE__*/_classPrivateFieldLooseKey(\"evaluator\");export class Program{/**\n   * @param entryPoints Expressions to evaluate when running the program. Order of evaluation is unspecified.\n   *                    Entry points that are global definitions may be referred to throughout the rest of the program,\n   *                    except when doing so would create a circular dependency.\n   */constructor(entryPoints){Object.defineProperty(this,_entryPointIndexPaths,{writable:true,value:void 0});Object.defineProperty(this,_evaluator,{writable:true,value:void 0});_classPrivateFieldLooseBase(this,_entryPointIndexPaths)[_entryPointIndexPaths]=entryPoints.map(ep=>\"tree\"in ep?ep:rootIndexPath(ep));}get evaluator(){if(!_classPrivateFieldLooseBase(this,_evaluator)[_evaluator]){_classPrivateFieldLooseBase(this,_evaluator)[_evaluator]=new Evaluator();_classPrivateFieldLooseBase(this,_evaluator)[_evaluator].addDefines(_classPrivateFieldLooseBase(this,_entryPointIndexPaths)[_entryPointIndexPaths]);}return _classPrivateFieldLooseBase(this,_evaluator)[_evaluator];}get defines(){return this.evaluator.defines;}evalInProgram(entryPoint){return evalFully(this.evaluator,{expr:nodeAtIndexPath(entryPoint),indexPath:entryPoint});}evalInProgramInteractively(entryPoint){return this.evaluator.eval({expr:nodeAtIndexPath(entryPoint),indexPath:entryPoint});}runAll(){for(const entryPoint of _classPrivateFieldLooseBase(this,_entryPointIndexPaths)[_entryPointIndexPaths]){this.evalInProgram(entryPoint);}}}","map":{"version":3,"names":["evalFully","Evaluator","nodeAtIndexPath","rootIndexPath","_entryPointIndexPaths","_classPrivateFieldLooseKey","_evaluator","Program","constructor","entryPoints","Object","defineProperty","writable","value","_classPrivateFieldLooseBase","map","ep","evaluator","addDefines","defines","evalInProgram","entryPoint","expr","indexPath","evalInProgramInteractively","eval","runAll"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/simulator/program.ts"],"sourcesContent":["import { evalFully, Evaluator } from \"../evaluator/evaluate\";\nimport { Value } from \"../evaluator/value\";\nimport { Defines } from \"../evaluator/defines\";\nimport { TreeIndexPath, nodeAtIndexPath, rootIndexPath } from \"../editor/trees/tree\";\nimport { Tree } from \"../editor/trees/trees\";\n\nexport class Program {\n  #entryPointIndexPaths: TreeIndexPath[];\n\n  /**\n   * @param entryPoints Expressions to evaluate when running the program. Order of evaluation is unspecified.\n   *                    Entry points that are global definitions may be referred to throughout the rest of the program,\n   *                    except when doing so would create a circular dependency.\n   */\n  constructor(entryPoints: (Tree | TreeIndexPath)[]) {\n    this.#entryPointIndexPaths = entryPoints.map(\n      (ep): TreeIndexPath => (\"tree\" in ep ? ep : rootIndexPath(ep)),\n    );\n  }\n\n  #evaluator?: Evaluator;\n\n  get evaluator(): Evaluator {\n    if (!this.#evaluator) {\n      this.#evaluator = new Evaluator();\n      this.#evaluator.addDefines(this.#entryPointIndexPaths);\n    }\n    return this.#evaluator;\n  }\n\n  get defines(): Defines {\n    return this.evaluator.defines;\n  }\n\n  evalInProgram(entryPoint: TreeIndexPath): Value | undefined {\n    return evalFully(this.evaluator, { expr: nodeAtIndexPath(entryPoint), indexPath: entryPoint });\n  }\n\n  evalInProgramInteractively(entryPoint: TreeIndexPath) {\n    return this.evaluator.eval({ expr: nodeAtIndexPath(entryPoint), indexPath: entryPoint });\n  }\n\n  runAll(): void {\n    for (const entryPoint of this.#entryPointIndexPaths) {\n      this.evalInProgram(entryPoint);\n    }\n  }\n}\n"],"mappings":"4UAAA,OAASA,SAAS,CAAEC,SAAS,KAAQ,uBAAuB,CAG5D,OAAwBC,eAAe,CAAEC,aAAa,KAAQ,sBAAsB,CAAC,IAAAC,qBAAA,cAAAC,0BAAA,6BAAAC,UAAA,cAAAD,0BAAA,cAGrF,MAAO,MAAM,CAAAE,OAAQ,CAGnB;AACF;AACA;AACA;AACA,KACEC,WAAWA,CAACC,WAAqC,CAAE,CAAAC,MAAA,CAAAC,cAAA,MAAAP,qBAAA,EAAAQ,QAAA,MAAAC,KAAA,UAAAH,MAAA,CAAAC,cAAA,MAAAL,UAAA,EAAAM,QAAA,MAAAC,KAAA,UACjDC,2BAAA,KAAI,CAAAV,qBAAA,EAAAA,qBAAA,EAAyBK,WAAW,CAACM,GAAG,CACzCC,EAAE,EAAqB,MAAM,EAAI,CAAAA,EAAE,CAAGA,EAAE,CAAGb,aAAa,CAACa,EAAE,CAC9D,CAAC,CACH,CAIA,GAAI,CAAAC,SAASA,CAAA,CAAc,CACzB,GAAI,CAAAH,2BAAA,CAAC,IAAI,CAAAR,UAAA,EAAAA,UAAA,CAAW,CAAE,CACpBQ,2BAAA,KAAI,CAAAR,UAAA,EAAAA,UAAA,EAAc,GAAI,CAAAL,SAAS,CAAC,CAAC,CACjCa,2BAAA,KAAI,CAAAR,UAAA,EAAAA,UAAA,EAAYY,UAAU,CAAAJ,2BAAA,CAAC,IAAI,CAAAV,qBAAA,EAAAA,qBAAA,CAAsB,CAAC,CACxD,CACA,OAAAU,2BAAA,CAAO,IAAI,CAAAR,UAAA,EAAAA,UAAA,EACb,CAEA,GAAI,CAAAa,OAAOA,CAAA,CAAY,CACrB,MAAO,KAAI,CAACF,SAAS,CAACE,OAAO,CAC/B,CAEAC,aAAaA,CAACC,UAAyB,CAAqB,CAC1D,MAAO,CAAArB,SAAS,CAAC,IAAI,CAACiB,SAAS,CAAE,CAAEK,IAAI,CAAEpB,eAAe,CAACmB,UAAU,CAAC,CAAEE,SAAS,CAAEF,UAAW,CAAC,CAAC,CAChG,CAEAG,0BAA0BA,CAACH,UAAyB,CAAE,CACpD,MAAO,KAAI,CAACJ,SAAS,CAACQ,IAAI,CAAC,CAAEH,IAAI,CAAEpB,eAAe,CAACmB,UAAU,CAAC,CAAEE,SAAS,CAAEF,UAAW,CAAC,CAAC,CAC1F,CAEAK,MAAMA,CAAA,CAAS,CACb,IAAK,KAAM,CAAAL,UAAU,IAAAP,2BAAA,CAAI,IAAI,CAAAV,qBAAA,EAAAA,qBAAA,EAAwB,CACnD,IAAI,CAACgB,aAAa,CAACC,UAAU,CAAC,CAChC,CACF,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}