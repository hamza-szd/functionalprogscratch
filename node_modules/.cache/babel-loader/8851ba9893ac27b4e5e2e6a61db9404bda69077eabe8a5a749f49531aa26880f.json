{"ast":null,"code":"export const DynamicTypeAny=\"Any\";export function prettyPrintSignature(signature){return signature.map(param=>(param.type?\"(\"+param.name+\" : \"+param.type+\")\":param.name)+(param.variadic?\"...\":param.optional?\"?\":\"\")).join(\" \");}export function prettyPrintSignatureNames(signature){return signature.map(param=>param.name+(param.variadic?\"...\":param.optional?\"?\":\"\")).join(\" \");}export function checkCallAgainstTypeSignature(argValues,signature){if(!dynamicSignatureMatch(argValues.map(value=>value.kind),signature)){throw{tag:\"DynamicSignatureMismatch\",argValues,signature};}}function dynamicSignatureMatch(actualTypes,signature){let params=[...signature];checkParam:for(const actual of actualTypes){let nextParam;while(true){var _nextParam$type;nextParam=params[0];if(nextParam===undefined){// Signature is out of parameters to match with\nreturn false;}if(!nextParam.variadic)params.shift();if(dynamicTypeAssignable((_nextParam$type=nextParam.type)!==null&&_nextParam$type!==void 0?_nextParam$type:DynamicTypeAny,actual)){// Matches\ncontinue checkParam;}else if(nextParam.variadic){// Try to match next\nparams.shift();continue;}else{// Failed to match non-variadic parameter\nreturn!!nextParam.optional;}}}return params.length===0||params[0].optional||params.every(param=>param.variadic);}function dynamicTypeAssignable(destination,source){return destination===DynamicTypeAny||destination===source;}","map":{"version":3,"names":["DynamicTypeAny","prettyPrintSignature","signature","map","param","type","name","variadic","optional","join","prettyPrintSignatureNames","checkCallAgainstTypeSignature","argValues","dynamicSignatureMatch","value","kind","tag","actualTypes","params","checkParam","actual","nextParam","_nextParam$type","undefined","shift","dynamicTypeAssignable","length","every","destination","source"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/evaluator/dynamic-type.ts"],"sourcesContent":["import { DynamicSignatureMismatch } from \"./errors\";\nimport { Value } from \"./value\";\n\nexport type DynamicType = string;\nexport const DynamicTypeAny = \"Any\";\n\nexport type DynamicFnSignature = DynamicParamSignature[];\nexport type DynamicParamSignature = {\n  name: string;\n  variadic?: boolean;\n  optional?: boolean;\n  type?: DynamicType;\n};\n\nexport function prettyPrintSignature(signature: DynamicFnSignature): string {\n  return signature\n    .map(\n      (param) =>\n        (param.type ? \"(\" + param.name + \" : \" + param.type + \")\" : param.name) +\n        (param.variadic ? \"...\" : param.optional ? \"?\" : \"\"),\n    )\n    .join(\" \");\n}\nexport function prettyPrintSignatureNames(signature: DynamicFnSignature): string {\n  return signature\n    .map((param) => param.name + (param.variadic ? \"...\" : param.optional ? \"?\" : \"\"))\n    .join(\" \");\n}\n\nexport function checkCallAgainstTypeSignature(\n  argValues: Value[],\n  signature: DynamicFnSignature,\n): void {\n  if (\n    !dynamicSignatureMatch(\n      argValues.map((value) => value.kind),\n      signature,\n    )\n  ) {\n    throw {\n      tag: \"DynamicSignatureMismatch\",\n      argValues,\n      signature,\n    } satisfies DynamicSignatureMismatch;\n  }\n}\n\nfunction dynamicSignatureMatch(actualTypes: DynamicType[], signature: DynamicFnSignature): boolean {\n  let params = [...signature];\n  checkParam: for (const actual of actualTypes) {\n    let nextParam: DynamicParamSignature | undefined;\n    while (true) {\n      nextParam = params[0];\n      if (nextParam === undefined) {\n        // Signature is out of parameters to match with\n        return false;\n      }\n      if (!nextParam.variadic) params.shift();\n\n      if (dynamicTypeAssignable(nextParam.type ?? DynamicTypeAny, actual)) {\n        // Matches\n        continue checkParam;\n      } else if (nextParam.variadic) {\n        // Try to match next\n        params.shift();\n        continue;\n      } else {\n        // Failed to match non-variadic parameter\n        return !!nextParam.optional;\n      }\n    }\n  }\n\n  return params.length === 0 || params[0]!.optional || params.every((param) => param.variadic);\n}\n\nfunction dynamicTypeAssignable(destination: DynamicType, source: DynamicType) {\n  return destination === DynamicTypeAny || destination === source;\n}\n"],"mappings":"AAIA,MAAO,MAAM,CAAAA,cAAc,CAAG,KAAK,CAUnC,MAAO,SAAS,CAAAC,oBAAoBA,CAACC,SAA6B,CAAU,CAC1E,MAAO,CAAAA,SAAS,CACbC,GAAG,CACDC,KAAK,EACJ,CAACA,KAAK,CAACC,IAAI,CAAG,GAAG,CAAGD,KAAK,CAACE,IAAI,CAAG,KAAK,CAAGF,KAAK,CAACC,IAAI,CAAG,GAAG,CAAGD,KAAK,CAACE,IAAI,GACrEF,KAAK,CAACG,QAAQ,CAAG,KAAK,CAAGH,KAAK,CAACI,QAAQ,CAAG,GAAG,CAAG,EAAE,CACvD,CAAC,CACAC,IAAI,CAAC,GAAG,CAAC,CACd,CACA,MAAO,SAAS,CAAAC,yBAAyBA,CAACR,SAA6B,CAAU,CAC/E,MAAO,CAAAA,SAAS,CACbC,GAAG,CAAEC,KAAK,EAAKA,KAAK,CAACE,IAAI,EAAIF,KAAK,CAACG,QAAQ,CAAG,KAAK,CAAGH,KAAK,CAACI,QAAQ,CAAG,GAAG,CAAG,EAAE,CAAC,CAAC,CACjFC,IAAI,CAAC,GAAG,CAAC,CACd,CAEA,MAAO,SAAS,CAAAE,6BAA6BA,CAC3CC,SAAkB,CAClBV,SAA6B,CACvB,CACN,GACE,CAACW,qBAAqB,CACpBD,SAAS,CAACT,GAAG,CAAEW,KAAK,EAAKA,KAAK,CAACC,IAAI,CAAC,CACpCb,SACF,CAAC,CACD,CACA,KAAM,CACJc,GAAG,CAAE,0BAA0B,CAC/BJ,SAAS,CACTV,SACF,CAAC,CACH,CACF,CAEA,QAAS,CAAAW,qBAAqBA,CAACI,WAA0B,CAAEf,SAA6B,CAAW,CACjG,GAAI,CAAAgB,MAAM,CAAG,CAAC,GAAGhB,SAAS,CAAC,CAC3BiB,UAAU,CAAE,IAAK,KAAM,CAAAC,MAAM,GAAI,CAAAH,WAAW,CAAE,CAC5C,GAAI,CAAAI,SAA4C,CAChD,MAAO,IAAI,CAAE,KAAAC,eAAA,CACXD,SAAS,CAAGH,MAAM,CAAC,CAAC,CAAC,CACrB,GAAIG,SAAS,GAAKE,SAAS,CAAE,CAC3B;AACA,MAAO,MAAK,CACd,CACA,GAAI,CAACF,SAAS,CAACd,QAAQ,CAAEW,MAAM,CAACM,KAAK,CAAC,CAAC,CAEvC,GAAIC,qBAAqB,EAAAH,eAAA,CAACD,SAAS,CAAChB,IAAI,UAAAiB,eAAA,UAAAA,eAAA,CAAItB,cAAc,CAAEoB,MAAM,CAAC,CAAE,CACnE;AACA,QAAS,CAAAD,UAAU,CACrB,CAAC,IAAM,IAAIE,SAAS,CAACd,QAAQ,CAAE,CAC7B;AACAW,MAAM,CAACM,KAAK,CAAC,CAAC,CACd,SACF,CAAC,IAAM,CACL;AACA,MAAO,CAAC,CAACH,SAAS,CAACb,QAAQ,CAC7B,CACF,CACF,CAEA,MAAO,CAAAU,MAAM,CAACQ,MAAM,GAAK,CAAC,EAAIR,MAAM,CAAC,CAAC,CAAC,CAAEV,QAAQ,EAAIU,MAAM,CAACS,KAAK,CAAEvB,KAAK,EAAKA,KAAK,CAACG,QAAQ,CAAC,CAC9F,CAEA,QAAS,CAAAkB,qBAAqBA,CAACG,WAAwB,CAAEC,MAAmB,CAAE,CAC5E,MAAO,CAAAD,WAAW,GAAK5B,cAAc,EAAI4B,WAAW,GAAKC,MAAM,CACjE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}