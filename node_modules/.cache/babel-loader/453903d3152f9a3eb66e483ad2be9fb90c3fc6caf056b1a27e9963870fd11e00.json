{"ast":null,"code":"import _classPrivateFieldLooseBase from\"/Users/hamzashahzad/Desktop/resume_projects/sparkground/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";import _classPrivateFieldLooseKey from\"/Users/hamzashahzad/Desktop/resume_projects/sparkground/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";import{extendIndexPath,hole,isHole,rootIndexPath}from\"../editor/trees/tree\";import{getIdentifier,getTypeAnnotation}from\"../expr/expr\";import{Never,Untyped,functionParamTypes,functionResultType,hasTag,isForallType}from\"./type\";import{InvisiblePageID}from\"../editor/trees/trees\";import{isSubtype,typeJoin}from\"./subtyping\";import{InitialTypeContext}from\"../editor/typecheck\";import{computeMinimalSubstitution,constraintSetsMeet}from\"./constraints/constraint-set\";import{eliminateUp,generateConstraints}from\"./constraints/constraint-gen\";import{typeSubstitute}from\"./type-substitution\";import{ErrorsByIndexPath}from\"../expr/errors\";import{TypeDefines}from\"./type-defines\";function bindInContext(context,binding){var _binding$type;return bindInContextWithType(context,binding,(_binding$type=binding.type)!==null&&_binding$type!==void 0?_binding$type:Untyped);}function bindInContextWithType(context,binding,newType){return{...context,[binding.id]:newType};}class InferenceCache{constructor(){this.inferred=new Map();}get(_ref){let{tree,path}=_ref;return this.inferred.get(tree.id+\"#\"+path.join(\".\"));}set(_ref2,type){let{tree,path}=_ref2;this.inferred.set(tree.id+\"#\"+path.join(\".\"),type);}clear(){this.inferred.clear();}}var _defines=/*#__PURE__*/_classPrivateFieldLooseKey(\"defines\");var _inferenceCache=/*#__PURE__*/_classPrivateFieldLooseKey(\"inferenceCache\");var _nextFakeTreeID=/*#__PURE__*/_classPrivateFieldLooseKey(\"nextFakeTreeID\");var _inferType=/*#__PURE__*/_classPrivateFieldLooseKey(\"inferType\");var _inferType_=/*#__PURE__*/_classPrivateFieldLooseKey(\"inferType_\");var _inferTypeFromDatum=/*#__PURE__*/_classPrivateFieldLooseKey(\"inferTypeFromDatum\");var _inferResultType=/*#__PURE__*/_classPrivateFieldLooseKey(\"inferResultType\");var _generateConstraints=/*#__PURE__*/_classPrivateFieldLooseKey(\"generateConstraints\");var _checkType=/*#__PURE__*/_classPrivateFieldLooseKey(\"checkType\");var _checkType_=/*#__PURE__*/_classPrivateFieldLooseKey(\"checkType_\");var _get=/*#__PURE__*/_classPrivateFieldLooseKey(\"get\");export class Typechecker{constructor(){let{baseContext,autoReset}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};Object.defineProperty(this,_get,{value:_get2});Object.defineProperty(this,_checkType_,{value:_checkType_2});/**\n   * Checks that `expr` has `type` in `context`.\n   */Object.defineProperty(this,_checkType,{value:_checkType2});Object.defineProperty(this,_generateConstraints,{value:_generateConstraints2});Object.defineProperty(this,_inferResultType,{value:_inferResultType2});Object.defineProperty(this,_inferTypeFromDatum,{value:_inferTypeFromDatum2});/**\n   * Infers the type of `expr` in `context` at `indexPath`.\n   */Object.defineProperty(this,_inferType_,{value:_inferType_2});Object.defineProperty(this,_inferType,{value:_inferType2});this.baseContext=void 0;this.errors=new ErrorsByIndexPath();this.autoReset=void 0;Object.defineProperty(this,_defines,{writable:true,value:new TypeDefines()});Object.defineProperty(this,_inferenceCache,{writable:true,value:new InferenceCache()});Object.defineProperty(this,_nextFakeTreeID,{writable:true,value:0});this.baseContext=baseContext!==null&&baseContext!==void 0?baseContext:InitialTypeContext;this.autoReset=autoReset!==null&&autoReset!==void 0?autoReset:false;}/**\n   * Wipes the typechecker state clean.\n   * all gone\n   *\n   * This is equivalent to just making a new typechecker, but resetting the state in\n   * `inferType()` and co. allows clients to just call them repeatedly on the same instance.\n   */reset(){// Clear public error state.\n// It is a new day.\nthis.errors.clear();_classPrivateFieldLooseBase(this,_defines)[_defines].clear();_classPrivateFieldLooseBase(this,_inferenceCache)[_inferenceCache].clear();}clearCache(){_classPrivateFieldLooseBase(this,_defines)[_defines].clearComputed();_classPrivateFieldLooseBase(this,_inferenceCache)[_inferenceCache].clear();}addDefines(trees){for(const tree of trees){try{const{root}=tree;switch(root.kind){case\"struct\":case\"define\":this.addDefine(tree);}}catch(error){// TODO: Remove this try/catch once eval() is changed to not throw any errors\nconsole.error(error);}}}addDefine(tree){const define=tree.root;if(_classPrivateFieldLooseBase(this,_defines)[_defines].has(getIdentifier(tree.root.name))){this.errors.add(rootIndexPath(tree),{tag:\"DuplicateDefinition\",id:define.name.id});}_classPrivateFieldLooseBase(this,_inferType)[_inferType](define,this.baseContext,rootIndexPath(tree));}inferType(tree){let context=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.baseContext;// If given an `Expr`, stuff it into its own tree before running inference,\n// as inference requires an index path into a tree (to deal with subexpressions).\nif(!(\"root\"in tree)){tree={id:`inferType-${_classPrivateFieldLooseBase(this,_nextFakeTreeID)[_nextFakeTreeID]++}`,root:tree,location:{x:-1000,y:-1000},page:InvisiblePageID,zIndex:-1000};}if(this.autoReset)this.reset();return _classPrivateFieldLooseBase(this,_inferType)[_inferType](tree.root,context,rootIndexPath(tree));}inferSubexprType(indexPath){let context=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.baseContext;if(this.autoReset)this.reset();// First, infer the type of the entire tree.\n_classPrivateFieldLooseBase(this,_inferType)[_inferType](indexPath.tree.root,context,rootIndexPath(indexPath.tree));// Cache inferred types for all defines, even if they are not used,\n// so that the editor can display them.\n_classPrivateFieldLooseBase(this,_defines)[_defines].computeAll();// We already computed the type of the entire expression, which visits every subexpression.\n// Thus, the inference cache should know the type of the subexpression pointed to by indexPath.\nconst inferredType=_classPrivateFieldLooseBase(this,_inferenceCache)[_inferenceCache].get(indexPath);if(!inferredType){console.error(\"no type in inference cache for index path :(\",indexPath);return Untyped;}return inferredType;}}function _inferType2(expr,context,indexPath){// If the type is cached, we're done.\nconst alreadyInferred=_classPrivateFieldLooseBase(this,_inferenceCache)[_inferenceCache].get(indexPath);if(alreadyInferred)return alreadyInferred;let inferred;try{inferred=_classPrivateFieldLooseBase(this,_inferType_)[_inferType_](expr,context,indexPath);}catch(error){if(typeof error===\"object\"&&\"tag\"in error){this.errors.add(indexPath,error);}else{console.error(error);}inferred=Untyped;}_classPrivateFieldLooseBase(this,_inferenceCache)[_inferenceCache].set(indexPath,inferred);return inferred;}function _inferType_2(expr,context,indexPath){switch(expr.kind){case\"Boolean\":case\"Number\":case\"String\":case\"Symbol\":case\"List\":return _classPrivateFieldLooseBase(this,_inferTypeFromDatum)[_inferTypeFromDatum](expr,context,indexPath);case\"var\":case\"name-binding\":{// For name-binding: this is *only* to update the inference cache.\nconst varType=_classPrivateFieldLooseBase(this,_get)[_get](expr.id,context);if(!varType)throw{tag:\"UnboundVariable\",v:expr};if(varType===\"circular\")return Untyped;// TODO: Old code was return this.#instantiate(varType, env);\nreturn varType;}case\"struct\":{// Cache annotated type for name binding node, so that the editor can display it.\nconst cacheBindingType=(name,indexPath,type)=>{_classPrivateFieldLooseBase(this,_inferType)[_inferType](name,isHole(name)?context:bindInContextWithType(context,name,type),indexPath);};_classPrivateFieldLooseBase(this,_defines)[_defines].addAll(expr.fields.map((fieldName,fieldIndex)=>[getIdentifier(fieldName),()=>{var _getTypeAnnotation;if(isHole(expr.name))return Untyped;// Synthesize field accessor type\nconst structName=getIdentifier(expr.name);const fieldType=(_getTypeAnnotation=getTypeAnnotation(fieldName))!==null&&_getTypeAnnotation!==void 0?_getTypeAnnotation:Untyped;const accessorType={tag:\"Function\",of:[{tag:structName},fieldType]};cacheBindingType(fieldName,extendIndexPath(indexPath,fieldIndex+1),accessorType);return accessorType;}]));_classPrivateFieldLooseBase(this,_defines)[_defines].add(getIdentifier(expr.name),()=>{if(isHole(expr.name))return Untyped;// Synthesize constructor type\nconst structName=getIdentifier(expr.name);const fieldTypes=expr.fields.map(fieldName=>{var _getTypeAnnotation2;return(_getTypeAnnotation2=getTypeAnnotation(fieldName))!==null&&_getTypeAnnotation2!==void 0?_getTypeAnnotation2:Untyped;});const constructorType={tag:\"Function\",of:[...fieldTypes,{tag:structName}]};cacheBindingType(expr.name,extendIndexPath(indexPath,0),constructorType);return constructorType;});return{tag:\"Empty\"};}case\"define\":{// Cache annotated or inferred type for name binding node, so that the editor can display it.\nconst cacheBindingType=(name,indexPath,type)=>{_classPrivateFieldLooseBase(this,_inferType)[_inferType](name,isHole(name)?context:bindInContextWithType(context,name,type),indexPath);};const typeAnnotation=getTypeAnnotation(expr.name);if(typeAnnotation){_classPrivateFieldLooseBase(this,_defines)[_defines].add(getIdentifier(expr.name),()=>{// Ensure this is a sound type annotation\n_classPrivateFieldLooseBase(this,_checkType)[_checkType](expr.value,typeAnnotation,context,extendIndexPath(indexPath,1));cacheBindingType(expr.name,extendIndexPath(indexPath,0),typeAnnotation);return typeAnnotation;});}else{// Make the definition visible to itself\n_classPrivateFieldLooseBase(this,_defines)[_defines].add(getIdentifier(expr.name),()=>{// Infer a type for the definition\nconst type=_classPrivateFieldLooseBase(this,_inferType)[_inferType](expr.value,context,extendIndexPath(indexPath,1));cacheBindingType(expr.name,extendIndexPath(indexPath,0),type);return type;});}return{tag:\"Empty\"};}case\"lambda\":{var _expr$returnType;let newContext=context;expr.params.forEach(param=>{if(!isHole(param)){newContext=bindInContext(newContext,param);}});// Cache inferred types for all parameters, even if they are not used in the lambda body,\n// so that the editor can display them\nexpr.params.forEach((param,index)=>{_classPrivateFieldLooseBase(this,_inferType)[_inferType](param,newContext,extendIndexPath(indexPath,index));});// Cache type for phantom \"+\" button (name hole) at the end of the parameter list\n_classPrivateFieldLooseBase(this,_inferType)[_inferType](hole,newContext,extendIndexPath(indexPath,expr.params.length));// Infer type of lambda body\nconst bodyType=_classPrivateFieldLooseBase(this,_inferType)[_inferType](expr.body,newContext,extendIndexPath(indexPath,expr.params.length+1));if(expr.returnType&&!isSubtype(bodyType,expr.returnType)){throw{tag:\"InvalidAssignmentToType\",expr:expr.body,type:expr.returnType};}return{tag:\"Function\",of:[...expr.params.map(param=>{var _ref3;return(_ref3=isHole(param)?undefined:param.type)!==null&&_ref3!==void 0?_ref3:Untyped;}),(_expr$returnType=expr.returnType)!==null&&_expr$returnType!==void 0?_expr$returnType:bodyType]};}case\"call\":{let calledType=_classPrivateFieldLooseBase(this,_inferType)[_inferType](expr.called,context,extendIndexPath(indexPath,0));let constrainVarNames=[];while(isForallType(calledType)){constrainVarNames.push(...calledType.forall.filter(_ref4=>{let{kind}=_ref4;return kind===\"type-name-binding\";}).map(_ref5=>{let{id}=_ref5;return id;}));calledType=calledType.body;}if(hasTag(calledType,Untyped.tag)){expr.args.forEach((arg,index)=>{_classPrivateFieldLooseBase(this,_inferType)[_inferType](arg,context,extendIndexPath(indexPath,index+1));});return Untyped;}else if(hasTag(calledType,Never.tag)){expr.args.forEach((arg,index)=>{_classPrivateFieldLooseBase(this,_inferType)[_inferType](arg,context,extendIndexPath(indexPath,index+1));});return Never;}else if(hasTag(calledType,\"Function*\")){var _calledType$minArgCou,_calledType$maxArgCou;// Variadic function\nconst variadicParamTypes=functionParamTypes(calledType);const resultType=functionResultType(calledType);if(!(((_calledType$minArgCou=calledType.minArgCount)!==null&&_calledType$minArgCou!==void 0?_calledType$minArgCou:0)<=expr.args.length&&expr.args.length<=((_calledType$maxArgCou=calledType.maxArgCount)!==null&&_calledType$maxArgCou!==void 0?_calledType$maxArgCou:Infinity))){this.errors.add(indexPath,{tag:\"VariadicArityMismatch\",call:expr,calledType,minArity:calledType.minArgCount,maxArity:calledType.maxArgCount,attemptedCallArity:expr.args.length});return resultType;}const argTypes=expr.args.map((arg,index)=>_classPrivateFieldLooseBase(this,_inferType)[_inferType](arg,context,extendIndexPath(indexPath,index+1)));const paramTypes=[...variadicParamTypes,...Array(Math.max(0,argTypes.length-variadicParamTypes.length)).fill(variadicParamTypes.at(-1))];const instantiatedResultType=_classPrivateFieldLooseBase(this,_inferResultType)[_inferResultType](constrainVarNames,expr.args,argTypes,paramTypes,resultType);if(instantiatedResultType===undefined){throw{tag:\"InvalidAssignment\",expr};}return instantiatedResultType;}else if(hasTag(calledType,\"Function\")){// Simple function\nconst paramTypes=functionParamTypes(calledType);const resultType=functionResultType(calledType);if(expr.args.length!==paramTypes.length){this.errors.add(indexPath,{tag:\"ArityMismatch\",call:expr,calledType,arity:paramTypes.length,attemptedCallArity:expr.args.length});return resultType;}const argTypes=expr.args.map((arg,index)=>_classPrivateFieldLooseBase(this,_inferType)[_inferType](arg,context,extendIndexPath(indexPath,index+1)));const instantiatedResultType=_classPrivateFieldLooseBase(this,_inferResultType)[_inferResultType](constrainVarNames,expr.args,argTypes,paramTypes,resultType);if(instantiatedResultType===undefined){throw{tag:\"InvalidAssignment\",expr};}return instantiatedResultType;}else{throw{tag:\"NotCallable\",call:expr,calledType};}}case\"let\":{let newContext=context;expr.bindings.forEach((_ref6,index)=>{let[name,value]=_ref6;if(!isHole(name)&&name.type){newContext=bindInContext(newContext,name);// Ensure this is a sound type annotation\n_classPrivateFieldLooseBase(this,_checkType)[_checkType](value,name.type,// Old context: This is plain `let`!\ncontext,extendIndexPath(indexPath,2*index+1));}else{// Infer a type for the definition\nconst inferredType=_classPrivateFieldLooseBase(this,_inferType)[_inferType](value,// Old context: This is plain `let`!\ncontext,extendIndexPath(indexPath,2*index+1));// Update the definition's type in the context\nif(!isHole(name)){newContext=bindInContextWithType(newContext,name,inferredType);}}});// Cache inferred types for name bindings in the new context,\n// so that the editor can display them\nexpr.bindings.forEach((_ref7,index)=>{let[name]=_ref7;_classPrivateFieldLooseBase(this,_inferType)[_inferType](name,newContext,extendIndexPath(indexPath,2*index));});return _classPrivateFieldLooseBase(this,_inferType)[_inferType](expr.body,newContext,extendIndexPath(indexPath,2*expr.bindings.length));}case\"letrec\":{let newContext=context;expr.bindings.forEach(_ref8=>{let[name]=_ref8;if(!isHole(name)){newContext=bindInContext(newContext,name);}});expr.bindings.forEach((_ref9,index)=>{let[name,value]=_ref9;if(!isHole(name)&&name.type){// Ensure this is a sound type annotation\n_classPrivateFieldLooseBase(this,_checkType)[_checkType](value,name.type,newContext,extendIndexPath(indexPath,2*index+1));}else{// Infer a type for the definition\nconst inferredType=_classPrivateFieldLooseBase(this,_inferType)[_inferType](value,newContext,extendIndexPath(indexPath,2*index+1));// Update the definition's type in the context\nif(!isHole(name)){newContext=bindInContextWithType(newContext,name,inferredType);}}});// Cache inferred types for name bindings in the new context,\n// so that the editor can display them\nexpr.bindings.forEach((_ref10,index)=>{let[name]=_ref10;_classPrivateFieldLooseBase(this,_inferType)[_inferType](name,newContext,extendIndexPath(indexPath,2*index));});return _classPrivateFieldLooseBase(this,_inferType)[_inferType](expr.body,newContext,extendIndexPath(indexPath,2*expr.bindings.length));}case\"sequence\":{let resultType=Untyped;expr.exprs.forEach((sequencedExpr,index)=>{resultType=_classPrivateFieldLooseBase(this,_inferType)[_inferType](sequencedExpr,context,extendIndexPath(indexPath,index));});return resultType;}case\"if\":_classPrivateFieldLooseBase(this,_inferType)[_inferType](expr.if,context,extendIndexPath(indexPath,0));const thenType=_classPrivateFieldLooseBase(this,_inferType)[_inferType](expr.then,context,extendIndexPath(indexPath,1));const elseType=_classPrivateFieldLooseBase(this,_inferType)[_inferType](expr.else,context,extendIndexPath(indexPath,2));return typeJoin(thenType,elseType);}throw\"TODO\";}function _inferTypeFromDatum2(datum,context,indexPath){switch(datum.kind){case\"Boolean\":return{tag:\"Boolean\"};case\"Number\":return datum.value===Math.floor(datum.value)?{tag:\"Integer\"}:{tag:\"Number\"};case\"String\":return{tag:\"String\"};case\"Symbol\":if(datum.value===\"·\")return Untyped;return{tag:\"Symbol\"};case\"List\":{let elementType=Never;datum.heads.forEach((head,index)=>{elementType=typeJoin(elementType,_classPrivateFieldLooseBase(this,_inferType)[_inferType](head,context,extendIndexPath(indexPath,index+1)));});if(datum.tail){elementType=typeJoin(elementType,_classPrivateFieldLooseBase(this,_inferType)[_inferType](datum.tail,context,extendIndexPath(indexPath,0)));}return{tag:\"List\",of:[elementType]};}}}function _inferResultType2(constrainVarNames,args,argTypes,paramTypes,resultType){const constraintSet=constraintSetsMeet(_classPrivateFieldLooseBase(this,_generateConstraints)[_generateConstraints](constrainVarNames,args,argTypes,paramTypes));if(!constraintSet)return undefined;const substitution=computeMinimalSubstitution(constraintSet,resultType);if(!substitution)return undefined;const substitutedResultType=typeSubstitute(resultType,substitution);return eliminateUp(constrainVarNames,substitutedResultType);}function _generateConstraints2(constrainVarNames,args,argTypes,paramTypes){const constraintSets=argTypes.map((argType,index)=>generateConstraints([],constrainVarNames,argType,paramTypes[index]));const invalidIndex=constraintSets.findIndex(set=>set===undefined);if(invalidIndex!==-1){throw{tag:\"InvalidAssignmentToType\",expr:args[invalidIndex],type:paramTypes[invalidIndex]};}return constraintSets;}function _checkType2(expr,type,context,indexPath){if(!_classPrivateFieldLooseBase(this,_checkType_)[_checkType_](expr,type,context,indexPath)){this.errors.add(indexPath,{tag:\"InvalidAssignmentToType\",expr,type});}}function _checkType_2(expr,type,context,indexPath){const exprType=_classPrivateFieldLooseBase(this,_inferType)[_inferType](expr,context,indexPath);if(hasTag(type,Untyped.tag))return true;return isSubtype(exprType,type);}function _get2(name,context){var _context$name;return(_context$name=context[name])!==null&&_context$name!==void 0?_context$name:_classPrivateFieldLooseBase(this,_defines)[_defines].get(name);}","map":{"version":3,"names":["extendIndexPath","hole","isHole","rootIndexPath","getIdentifier","getTypeAnnotation","Never","Untyped","functionParamTypes","functionResultType","hasTag","isForallType","InvisiblePageID","isSubtype","typeJoin","InitialTypeContext","computeMinimalSubstitution","constraintSetsMeet","eliminateUp","generateConstraints","typeSubstitute","ErrorsByIndexPath","TypeDefines","bindInContext","context","binding","_binding$type","bindInContextWithType","type","newType","id","InferenceCache","constructor","inferred","Map","get","_ref","tree","path","join","set","_ref2","clear","_defines","_classPrivateFieldLooseKey","_inferenceCache","_nextFakeTreeID","_inferType","_inferType_","_inferTypeFromDatum","_inferResultType","_generateConstraints","_checkType","_checkType_","_get","Typechecker","baseContext","autoReset","arguments","length","undefined","Object","defineProperty","value","_get2","_checkType_2","_checkType2","_generateConstraints2","_inferResultType2","_inferTypeFromDatum2","_inferType_2","_inferType2","errors","writable","reset","_classPrivateFieldLooseBase","clearCache","clearComputed","addDefines","trees","root","kind","addDefine","error","console","define","has","name","add","tag","inferType","location","x","y","page","zIndex","inferSubexprType","indexPath","computeAll","inferredType","expr","alreadyInferred","varType","v","cacheBindingType","addAll","fields","map","fieldName","fieldIndex","_getTypeAnnotation","structName","fieldType","accessorType","of","fieldTypes","_getTypeAnnotation2","constructorType","typeAnnotation","_expr$returnType","newContext","params","forEach","param","index","bodyType","body","returnType","_ref3","calledType","called","constrainVarNames","push","forall","filter","_ref4","_ref5","args","arg","_calledType$minArgCou","_calledType$maxArgCou","variadicParamTypes","resultType","minArgCount","maxArgCount","Infinity","call","minArity","maxArity","attemptedCallArity","argTypes","paramTypes","Array","Math","max","fill","at","instantiatedResultType","arity","bindings","_ref6","_ref7","_ref8","_ref9","_ref10","exprs","sequencedExpr","if","thenType","then","elseType","else","datum","floor","elementType","heads","head","tail","constraintSet","substitution","substitutedResultType","constraintSets","argType","invalidIndex","findIndex","exprType","_context$name"],"sources":["/Users/hamzashahzad/Desktop/resume_projects/sparkground/src/typechecker/typecheck.ts"],"sourcesContent":["import { Datum } from \"../datum/datum\";\nimport { TreeIndexPath, extendIndexPath, hole, isHole, rootIndexPath } from \"../editor/trees/tree\";\nimport {\n  Define,\n  Expr,\n  NameBinding,\n  Struct,\n  VarSlot,\n  getIdentifier,\n  getTypeAnnotation,\n} from \"../expr/expr\";\nimport {\n  ArityMismatch,\n  DuplicateDefinition,\n  TypecheckError,\n  InvalidAssignment,\n  InvalidAssignmentToType,\n  NotCallable,\n  UnboundVariable,\n  VariadicArityMismatch,\n} from \"./errors\";\nimport {\n  Never,\n  SimpleConcreteType,\n  Type,\n  TypeNameBinding,\n  Untyped,\n  functionParamTypes,\n  functionResultType,\n  hasTag,\n  isForallType,\n} from \"./type\";\nimport { InvisiblePageID, Tree } from \"../editor/trees/trees\";\nimport { isSubtype, typeJoin } from \"./subtyping\";\nimport { InitialTypeContext } from \"../editor/typecheck\";\nimport {\n  ConstraintSet,\n  computeMinimalSubstitution,\n  constraintSetsMeet,\n} from \"./constraints/constraint-set\";\nimport { eliminateUp, generateConstraints } from \"./constraints/constraint-gen\";\nimport { typeSubstitute } from \"./type-substitution\";\nimport { ErrorsByIndexPath } from \"../expr/errors\";\nimport { TypeDefines } from \"./type-defines\";\n\nexport type TypeContext = Record<string, Type>;\n\nfunction bindInContext(context: TypeContext, binding: NameBinding): TypeContext {\n  return bindInContextWithType(context, binding, binding.type ?? Untyped);\n}\nfunction bindInContextWithType(\n  context: TypeContext,\n  binding: NameBinding,\n  newType: Type,\n): TypeContext {\n  return {\n    ...context,\n    [binding.id]: newType,\n  };\n}\n\nclass InferenceCache {\n  inferred = new Map<string, Type>();\n\n  get({ tree, path }: TreeIndexPath): Type | undefined {\n    return this.inferred.get(tree.id + \"#\" + path.join(\".\"));\n  }\n\n  set({ tree, path }: TreeIndexPath, type: Type) {\n    this.inferred.set(tree.id + \"#\" + path.join(\".\"), type);\n  }\n\n  clear() {\n    this.inferred.clear();\n  }\n}\n\nexport class Typechecker {\n  baseContext: TypeContext;\n\n  errors: ErrorsByIndexPath<TypecheckError> = new ErrorsByIndexPath();\n  autoReset: boolean;\n\n  #defines: TypeDefines = new TypeDefines();\n  #inferenceCache = new InferenceCache();\n\n  #nextFakeTreeID = 0;\n\n  constructor({\n    baseContext,\n    autoReset,\n  }: {\n    baseContext?: TypeContext;\n    autoReset?: boolean;\n  } = {}) {\n    this.baseContext = baseContext ?? InitialTypeContext;\n    this.autoReset = autoReset ?? false;\n  }\n\n  /**\n   * Wipes the typechecker state clean.\n   * all gone\n   *\n   * This is equivalent to just making a new typechecker, but resetting the state in\n   * `inferType()` and co. allows clients to just call them repeatedly on the same instance.\n   */\n  reset() {\n    // Clear public error state.\n    // It is a new day.\n    this.errors.clear();\n\n    this.#defines.clear();\n    this.#inferenceCache.clear();\n  }\n\n  clearCache() {\n    this.#defines.clearComputed();\n    this.#inferenceCache.clear();\n  }\n\n  addDefines(trees: Tree[]) {\n    for (const tree of trees) {\n      try {\n        const { root } = tree;\n        switch (root.kind) {\n          case \"struct\":\n          case \"define\":\n            this.addDefine(tree as Tree<typeof root>);\n        }\n      } catch (error) {\n        // TODO: Remove this try/catch once eval() is changed to not throw any errors\n        console.error(error);\n      }\n    }\n  }\n\n  addDefine(tree: Tree<Define | Struct>): void {\n    const define = tree.root;\n\n    if (this.#defines.has(getIdentifier(tree.root.name))) {\n      this.errors.add(rootIndexPath(tree), {\n        tag: \"DuplicateDefinition\",\n        id: (define.name as NameBinding).id,\n      } satisfies DuplicateDefinition);\n    }\n\n    this.#inferType(define, this.baseContext, rootIndexPath(tree));\n  }\n\n  inferType(tree: Tree, context?: TypeContext): Type;\n  inferType(expr: Expr, context?: TypeContext): Type;\n  inferType(tree: Tree | Expr, context: TypeContext = this.baseContext): Type {\n    // If given an `Expr`, stuff it into its own tree before running inference,\n    // as inference requires an index path into a tree (to deal with subexpressions).\n    if (!(\"root\" in tree)) {\n      tree = {\n        id: `inferType-${this.#nextFakeTreeID++}`,\n        root: tree,\n        location: { x: -1000, y: -1000 },\n        page: InvisiblePageID,\n        zIndex: -1000,\n      } satisfies Tree;\n    }\n\n    if (this.autoReset) this.reset();\n    return this.#inferType(tree.root, context, rootIndexPath(tree));\n  }\n\n  inferSubexprType(indexPath: TreeIndexPath, context: TypeContext = this.baseContext): Type {\n    if (this.autoReset) this.reset();\n\n    // First, infer the type of the entire tree.\n    this.#inferType(indexPath.tree.root, context, rootIndexPath(indexPath.tree));\n\n    // Cache inferred types for all defines, even if they are not used,\n    // so that the editor can display them.\n    this.#defines.computeAll();\n\n    // We already computed the type of the entire expression, which visits every subexpression.\n    // Thus, the inference cache should know the type of the subexpression pointed to by indexPath.\n    const inferredType = this.#inferenceCache.get(indexPath);\n    if (!inferredType) {\n      console.error(\"no type in inference cache for index path :(\", indexPath);\n      return Untyped;\n    }\n\n    return inferredType;\n  }\n\n  #inferType(expr: Expr, context: TypeContext, indexPath: TreeIndexPath): Type {\n    // If the type is cached, we're done.\n    const alreadyInferred = this.#inferenceCache.get(indexPath);\n    if (alreadyInferred) return alreadyInferred;\n\n    let inferred: Type;\n    try {\n      inferred = this.#inferType_(expr, context, indexPath);\n    } catch (error) {\n      if (typeof error === \"object\" && \"tag\" in error) {\n        this.errors.add(indexPath, error as TypecheckError);\n      } else {\n        console.error(error);\n      }\n      inferred = Untyped;\n    }\n\n    this.#inferenceCache.set(indexPath, inferred);\n    return inferred;\n  }\n\n  /**\n   * Infers the type of `expr` in `context` at `indexPath`.\n   */\n  #inferType_(expr: Expr, context: TypeContext, indexPath: TreeIndexPath): Type {\n    switch (expr.kind) {\n      case \"Boolean\":\n      case \"Number\":\n      case \"String\":\n      case \"Symbol\":\n      case \"List\":\n        return this.#inferTypeFromDatum(expr, context, indexPath);\n\n      case \"var\":\n      case \"name-binding\": {\n        // For name-binding: this is *only* to update the inference cache.\n\n        const varType = this.#get(expr.id, context);\n        if (!varType) throw { tag: \"UnboundVariable\", v: expr } satisfies UnboundVariable;\n        if (varType === \"circular\") return Untyped;\n\n        // TODO: Old code was return this.#instantiate(varType, env);\n        return varType;\n      }\n\n      case \"struct\": {\n        // Cache annotated type for name binding node, so that the editor can display it.\n        const cacheBindingType = (name: VarSlot, indexPath: TreeIndexPath, type: Type) => {\n          this.#inferType(\n            name,\n            isHole(name) ? context : bindInContextWithType(context, name, type),\n            indexPath,\n          );\n        };\n\n        this.#defines.addAll(\n          expr.fields.map((fieldName, fieldIndex) => [\n            getIdentifier(fieldName),\n            (): Type => {\n              if (isHole(expr.name)) return Untyped;\n\n              // Synthesize field accessor type\n              const structName = getIdentifier(expr.name);\n              const fieldType = getTypeAnnotation(fieldName) ?? Untyped;\n              const accessorType: SimpleConcreteType<\"Function\"> = {\n                tag: \"Function\",\n                of: [{ tag: structName }, fieldType],\n              };\n\n              cacheBindingType(fieldName, extendIndexPath(indexPath, fieldIndex + 1), accessorType);\n              return accessorType;\n            },\n          ]),\n        );\n\n        this.#defines.add(getIdentifier(expr.name), () => {\n          if (isHole(expr.name)) return Untyped;\n\n          // Synthesize constructor type\n          const structName = getIdentifier(expr.name);\n          const fieldTypes = expr.fields.map(\n            (fieldName) => getTypeAnnotation(fieldName) ?? Untyped,\n          );\n          const constructorType: SimpleConcreteType<\"Function\"> = {\n            tag: \"Function\",\n            of: [...fieldTypes, { tag: structName }],\n          };\n\n          cacheBindingType(expr.name, extendIndexPath(indexPath, 0), constructorType);\n          return constructorType;\n        });\n\n        return { tag: \"Empty\" };\n      }\n\n      case \"define\": {\n        // Cache annotated or inferred type for name binding node, so that the editor can display it.\n        const cacheBindingType = (name: VarSlot, indexPath: TreeIndexPath, type: Type) => {\n          this.#inferType(\n            name,\n            isHole(name) ? context : bindInContextWithType(context, name, type),\n            indexPath,\n          );\n        };\n\n        const typeAnnotation = getTypeAnnotation(expr.name);\n        if (typeAnnotation) {\n          this.#defines.add(getIdentifier(expr.name), () => {\n            // Ensure this is a sound type annotation\n            this.#checkType(expr.value, typeAnnotation, context, extendIndexPath(indexPath, 1));\n\n            cacheBindingType(expr.name, extendIndexPath(indexPath, 0), typeAnnotation);\n            return typeAnnotation;\n          });\n        } else {\n          // Make the definition visible to itself\n          this.#defines.add(getIdentifier(expr.name), () => {\n            // Infer a type for the definition\n            const type = this.#inferType(expr.value, context, extendIndexPath(indexPath, 1));\n\n            cacheBindingType(expr.name, extendIndexPath(indexPath, 0), type);\n            return type;\n          });\n        }\n\n        return { tag: \"Empty\" };\n      }\n\n      case \"lambda\": {\n        let newContext = context;\n        expr.params.forEach((param) => {\n          if (!isHole(param)) {\n            newContext = bindInContext(newContext, param);\n          }\n        });\n\n        // Cache inferred types for all parameters, even if they are not used in the lambda body,\n        // so that the editor can display them\n        expr.params.forEach((param, index) => {\n          this.#inferType(param, newContext, extendIndexPath(indexPath, index));\n        });\n\n        // Cache type for phantom \"+\" button (name hole) at the end of the parameter list\n        this.#inferType(hole, newContext, extendIndexPath(indexPath, expr.params.length));\n\n        // Infer type of lambda body\n        const bodyType = this.#inferType(\n          expr.body,\n          newContext,\n          extendIndexPath(indexPath, expr.params.length + 1),\n        );\n\n        if (expr.returnType && !isSubtype(bodyType, expr.returnType)) {\n          throw {\n            tag: \"InvalidAssignmentToType\",\n            expr: expr.body,\n            type: expr.returnType,\n          } satisfies InvalidAssignmentToType;\n        }\n\n        return {\n          tag: \"Function\",\n          of: [\n            ...expr.params.map((param) => (isHole(param) ? undefined : param.type) ?? Untyped),\n            expr.returnType ?? bodyType,\n          ],\n        };\n      }\n\n      case \"call\": {\n        let calledType = this.#inferType(expr.called, context, extendIndexPath(indexPath, 0));\n\n        let constrainVarNames: string[] = [];\n        while (isForallType(calledType)) {\n          constrainVarNames.push(\n            ...(\n              calledType.forall.filter(\n                ({ kind }) => kind === \"type-name-binding\",\n              ) as TypeNameBinding[]\n            ).map(({ id }) => id),\n          );\n          calledType = calledType.body;\n        }\n\n        if (hasTag(calledType, Untyped.tag)) {\n          expr.args.forEach((arg, index) => {\n            this.#inferType(arg, context, extendIndexPath(indexPath, index + 1));\n          });\n          return Untyped;\n        } else if (hasTag(calledType, Never.tag)) {\n          expr.args.forEach((arg, index) => {\n            this.#inferType(arg, context, extendIndexPath(indexPath, index + 1));\n          });\n          return Never;\n        } else if (hasTag(calledType, \"Function*\")) {\n          // Variadic function\n\n          const variadicParamTypes = functionParamTypes(calledType);\n          const resultType = functionResultType(calledType);\n\n          if (\n            !(\n              (calledType.minArgCount ?? 0) <= expr.args.length &&\n              expr.args.length <= (calledType.maxArgCount ?? Infinity)\n            )\n          ) {\n            this.errors.add(indexPath, {\n              tag: \"VariadicArityMismatch\",\n              call: expr,\n              calledType,\n              minArity: calledType.minArgCount,\n              maxArity: calledType.maxArgCount,\n              attemptedCallArity: expr.args.length,\n            } satisfies VariadicArityMismatch);\n            return resultType;\n          }\n\n          const argTypes = expr.args.map((arg, index) =>\n            this.#inferType(arg, context, extendIndexPath(indexPath, index + 1)),\n          );\n          const paramTypes = [\n            ...variadicParamTypes,\n            ...Array(Math.max(0, argTypes.length - variadicParamTypes.length)).fill(\n              variadicParamTypes.at(-1)!,\n            ),\n          ];\n\n          const instantiatedResultType = this.#inferResultType(\n            constrainVarNames,\n            expr.args,\n            argTypes,\n            paramTypes,\n            resultType,\n          );\n          if (instantiatedResultType === undefined) {\n            throw {\n              tag: \"InvalidAssignment\",\n              expr,\n            } satisfies InvalidAssignment;\n          }\n\n          return instantiatedResultType;\n        } else if (hasTag(calledType, \"Function\")) {\n          // Simple function\n\n          const paramTypes = functionParamTypes(calledType);\n          const resultType = functionResultType(calledType);\n\n          if (expr.args.length !== paramTypes.length) {\n            this.errors.add(indexPath, {\n              tag: \"ArityMismatch\",\n              call: expr,\n              calledType,\n              arity: paramTypes.length,\n              attemptedCallArity: expr.args.length,\n            } satisfies ArityMismatch);\n            return resultType;\n          }\n\n          const argTypes = expr.args.map((arg, index) =>\n            this.#inferType(arg, context, extendIndexPath(indexPath, index + 1)),\n          );\n\n          const instantiatedResultType = this.#inferResultType(\n            constrainVarNames,\n            expr.args,\n            argTypes,\n            paramTypes,\n            resultType,\n          );\n          if (instantiatedResultType === undefined) {\n            throw {\n              tag: \"InvalidAssignment\",\n              expr,\n            } satisfies InvalidAssignment;\n          }\n\n          return instantiatedResultType;\n        } else {\n          throw { tag: \"NotCallable\", call: expr, calledType } satisfies NotCallable;\n        }\n      }\n\n      case \"let\": {\n        let newContext = context;\n        expr.bindings.forEach(([name, value], index) => {\n          if (!isHole(name) && name.type) {\n            newContext = bindInContext(newContext, name);\n\n            // Ensure this is a sound type annotation\n            this.#checkType(\n              value,\n              name.type,\n              // Old context: This is plain `let`!\n              context,\n              extendIndexPath(indexPath, 2 * index + 1),\n            );\n          } else {\n            // Infer a type for the definition\n            const inferredType = this.#inferType(\n              value,\n              // Old context: This is plain `let`!\n              context,\n              extendIndexPath(indexPath, 2 * index + 1),\n            );\n\n            // Update the definition's type in the context\n            if (!isHole(name)) {\n              newContext = bindInContextWithType(newContext, name, inferredType);\n            }\n          }\n        });\n\n        // Cache inferred types for name bindings in the new context,\n        // so that the editor can display them\n        expr.bindings.forEach(([name], index) => {\n          this.#inferType(name, newContext, extendIndexPath(indexPath, 2 * index));\n        });\n\n        return this.#inferType(\n          expr.body,\n          newContext,\n          extendIndexPath(indexPath, 2 * expr.bindings.length),\n        );\n      }\n\n      case \"letrec\": {\n        let newContext = context;\n        expr.bindings.forEach(([name]) => {\n          if (!isHole(name)) {\n            newContext = bindInContext(newContext, name);\n          }\n        });\n\n        expr.bindings.forEach(([name, value], index) => {\n          if (!isHole(name) && name.type) {\n            // Ensure this is a sound type annotation\n            this.#checkType(\n              value,\n              name.type,\n              newContext,\n              extendIndexPath(indexPath, 2 * index + 1),\n            );\n          } else {\n            // Infer a type for the definition\n            const inferredType = this.#inferType(\n              value,\n              newContext,\n              extendIndexPath(indexPath, 2 * index + 1),\n            );\n\n            // Update the definition's type in the context\n            if (!isHole(name)) {\n              newContext = bindInContextWithType(newContext, name, inferredType);\n            }\n          }\n        });\n\n        // Cache inferred types for name bindings in the new context,\n        // so that the editor can display them\n        expr.bindings.forEach(([name], index) => {\n          this.#inferType(name, newContext, extendIndexPath(indexPath, 2 * index));\n        });\n\n        return this.#inferType(\n          expr.body,\n          newContext,\n          extendIndexPath(indexPath, 2 * expr.bindings.length),\n        );\n      }\n\n      case \"sequence\": {\n        let resultType: Type = Untyped;\n\n        expr.exprs.forEach((sequencedExpr, index) => {\n          resultType = this.#inferType(sequencedExpr, context, extendIndexPath(indexPath, index));\n        });\n\n        return resultType;\n      }\n\n      case \"if\":\n        this.#inferType(expr.if, context, extendIndexPath(indexPath, 0));\n        const thenType = this.#inferType(expr.then, context, extendIndexPath(indexPath, 1));\n        const elseType = this.#inferType(expr.else, context, extendIndexPath(indexPath, 2));\n\n        return typeJoin(thenType, elseType);\n    }\n\n    throw \"TODO\";\n  }\n\n  #inferTypeFromDatum(datum: Datum, context: TypeContext, indexPath: TreeIndexPath): Type {\n    switch (datum.kind) {\n      case \"Boolean\":\n        return { tag: \"Boolean\" };\n      case \"Number\":\n        return datum.value === Math.floor(datum.value) ? { tag: \"Integer\" } : { tag: \"Number\" };\n      case \"String\":\n        return { tag: \"String\" };\n      case \"Symbol\":\n        if (datum.value === \"·\") return Untyped;\n        return { tag: \"Symbol\" };\n      case \"List\": {\n        let elementType: Type = Never;\n\n        datum.heads.forEach((head, index) => {\n          elementType = typeJoin(\n            elementType,\n            this.#inferType(head, context, extendIndexPath(indexPath, index + 1)),\n          );\n        });\n\n        if (datum.tail) {\n          elementType = typeJoin(\n            elementType,\n            this.#inferType(datum.tail, context, extendIndexPath(indexPath, 0)),\n          );\n        }\n\n        return { tag: \"List\", of: [elementType] };\n      }\n    }\n  }\n\n  #inferResultType(\n    constrainVarNames: string[],\n    args: Expr[],\n    argTypes: Type[],\n    paramTypes: Type[],\n    resultType: Type,\n  ): Type | undefined {\n    const constraintSet = constraintSetsMeet(\n      this.#generateConstraints(constrainVarNames, args, argTypes, paramTypes),\n    );\n    if (!constraintSet) return undefined;\n\n    const substitution = computeMinimalSubstitution(constraintSet, resultType);\n    if (!substitution) return undefined;\n\n    const substitutedResultType = typeSubstitute(resultType, substitution);\n    return eliminateUp(constrainVarNames, substitutedResultType);\n  }\n\n  #generateConstraints(\n    constrainVarNames: string[],\n    args: Expr[],\n    argTypes: Type[],\n    paramTypes: Type[],\n  ) {\n    const constraintSets: (ConstraintSet | undefined)[] = argTypes.map((argType, index) =>\n      generateConstraints([], constrainVarNames, argType, paramTypes[index]!),\n    );\n\n    const invalidIndex = constraintSets.findIndex((set) => set === undefined);\n    if (invalidIndex !== -1) {\n      throw {\n        tag: \"InvalidAssignmentToType\",\n        expr: args[invalidIndex]!,\n        type: paramTypes[invalidIndex]!,\n      } satisfies InvalidAssignmentToType;\n    }\n    return constraintSets as ConstraintSet[];\n  }\n\n  /**\n   * Checks that `expr` has `type` in `context`.\n   */\n  #checkType(expr: Expr, type: Type, context: TypeContext, indexPath: TreeIndexPath): void {\n    if (!this.#checkType_(expr, type, context, indexPath)) {\n      this.errors.add(indexPath, {\n        tag: \"InvalidAssignmentToType\",\n        expr,\n        type,\n      } satisfies InvalidAssignmentToType);\n    }\n  }\n\n  #checkType_(expr: Expr, type: Type, context: TypeContext, indexPath: TreeIndexPath): boolean {\n    const exprType = this.#inferType(expr, context, indexPath);\n\n    if (hasTag(type, Untyped.tag)) return true;\n\n    return isSubtype(exprType, type);\n  }\n\n  #get(name: string, context: TypeContext): Type | undefined | \"circular\" {\n    return context[name] ?? this.#defines.get(name);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}